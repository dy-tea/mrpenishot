@[translated]
module wl

#flag linux -I/usr/include
#include <wayland-client-protocol.h>

// Generated by wayland-scanner 1.24.0
//* *@page page_wayland The wayland protocol
// *@section page_ifaces_wayland Interfaces
// *- @subpage page_iface_wl_display - core global object
// *- @subpage page_iface_wl_registry - global registry object
// *- @subpage page_iface_wl_callback - callback object
// *- @subpage page_iface_wl_compositor - the compositor singleton
// *- @subpage page_iface_wl_shm_pool - a shared memory pool
// *- @subpage page_iface_wl_shm - shared memory support
// *- @subpage page_iface_wl_buffer - content for a C.wl_surface
// *- @subpage page_iface_C.wl_data_offer - offer to transfer data
// *- @subpage page_iface_wl_data_source - offer to transfer data
// *- @subpage page_iface_wl_data_device - data transfer device
// *- @subpage page_iface_wl_data_device_manager - data transfer interface
// *- @subpage page_iface_wl_shell - create desktop-style surfaces
// *- @subpage page_iface_wl_shell_surface - desktop-style metadata interface
// *- @subpage page_iface_C.wl_surface - an onscreen surface
// *- @subpage page_iface_wl_seat - group of input devices
// *- @subpage page_iface_C.wl_pointer - pointer input device
// *- @subpage page_iface_wl_keyboard - keyboard input device
// *- @subpage page_iface_wl_touch - touchscreen input device
// *- @subpage page_iface_wl_output - compositor output region
// *- @subpage page_iface_wl_region - region interface
// *- @subpage page_iface_wl_subcompositor - sub-surface compositing
// *- @subpage page_iface_wl_subsurface - sub-surface interface to a C.wl_surface
// *- @subpage page_iface_wl_fixes - wayland protocol fixes
// *@section page_copyright_wayland Copyright
// *<pre>
// * *Copyright Â© 2008-2011 Kristian HÃ¸gsberg
// *Copyright Â© 2010-2011 Intel Corporation
// *Copyright Â© 2012-2013 Collabora, Ltd.
// * *Permission is hereby granted, free of charge, to any person
// *obtaining a copy of this software and associated documentation files
// *(the "Software"), to deal in the Software without restriction,
// *including without limitation the rights to use, copy, modify, merge,
// *publish, distribute, sublicense, and/or sell copies of the Software,
// *and to permit persons to whom the Software is furnished to do so,
// *subject to the following conditions:
// * *The above copyright notice and this permission notice (including the
// *next paragraph) shall be included in all copies or substantial
// *portions of the Software.
// * *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// *EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// *MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// *NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
// *BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// *ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// *CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// *SOFTWARE.
// *</pre>
//
struct C.wl_buffer {
}
//* *@page page_iface_wl_display wl_display
// *@section page_iface_wl_display_desc Description
// * *The core global object.  This is a special singleton object.  It
// *is used for internal Wayland protocol features.
// *@section page_iface_wl_display_api API
// *See @ref iface_wl_display.
//
//* *@defgroup iface_wl_display The wl_display interface
// * *The core global object.  This is a special singleton object.  It
// *is used for internal Wayland protocol features.
//
//* *@page page_iface_wl_registry wl_registry
// *@section page_iface_wl_registry_desc Description
// * *The singleton global registry object.  The server has a number of
// *global objects that are available to all clients.  These objects
// *typically represent an actual object in the server (for example,
// *an input device) or they are singleton objects that provide
// *extension functionality.
// * *When a client creates a registry object, the registry object
// *will emit a global event for each global currently in the
// *registry.  Globals come and go as a result of device or
// *monitor hotplugs, reconfiguration or other events, and the
// *registry will send out global and global_remove events to
// *keep the client up to date with the changes.  To mark the end
// *of the initial burst of events, the client can use the
// *wl_display.sync request immediately after calling
// *wl_display.get_registry.
// * *A client can bind to a global object by using the bind
// *request.  This creates a client-side handle that lets the object
// *emit events to the client and lets the client invoke requests on
// *the object.
// *@section page_iface_wl_registry_api API
// *See @ref iface_wl_registry.
//
//* *@defgroup iface_wl_registry The wl_registry interface
// * *The singleton global registry object.  The server has a number of
// *global objects that are available to all clients.  These objects
// *typically represent an actual object in the server (for example,
// *an input device) or they are singleton objects that provide
// *extension functionality.
// * *When a client creates a registry object, the registry object
// *will emit a global event for each global currently in the
// *registry.  Globals come and go as a result of device or
// *monitor hotplugs, reconfiguration or other events, and the
// *registry will send out global and global_remove events to
// *keep the client up to date with the changes.  To mark the end
// *of the initial burst of events, the client can use the
// *wl_display.sync request immediately after calling
// *wl_display.get_registry.
// * *A client can bind to a global object by using the bind
// *request.  This creates a client-side handle that lets the object
// *emit events to the client and lets the client invoke requests on
// *the object.
//
//* *@page page_iface_wl_callback wl_callback
// *@section page_iface_wl_callback_desc Description
// * *Clients can handle the 'done' event to get notified when
// *the related request is done.
// * *Note, because wl_callback objects are created from multiple independent
// *factory interfaces, the wl_callback interface is frozen at version 1.
// *@section page_iface_wl_callback_api API
// *See @ref iface_wl_callback.
//
//* *@defgroup iface_wl_callback The wl_callback interface
// * *Clients can handle the 'done' event to get notified when
// *the related request is done.
// * *Note, because wl_callback objects are created from multiple independent
// *factory interfaces, the wl_callback interface is frozen at version 1.
//
//* *@page page_iface_wl_compositor wl_compositor
// *@section page_iface_wl_compositor_desc Description
// * *A compositor.  This object is a singleton global.  The
// *compositor is in charge of combining the contents of multiple
// *surfaces into one displayable output.
// *@section page_iface_wl_compositor_api API
// *See @ref iface_wl_compositor.
//
//* *@defgroup iface_wl_compositor The wl_compositor interface
// * *A compositor.  This object is a singleton global.  The
// *compositor is in charge of combining the contents of multiple
// *surfaces into one displayable output.
//
//* *@page page_iface_wl_shm_pool wl_shm_pool
// *@section page_iface_wl_shm_pool_desc Description
// * *The wl_shm_pool object encapsulates a piece of memory shared
// *between the compositor and client.  Through the wl_shm_pool
// *object, the client can allocate shared memory wl_buffer objects.
// *All objects created through the same pool share the same
// *underlying mapped memory. Reusing the mapped memory avoids the
// *setup/teardown overhead and is useful when interactively resizing
// *a surface or for many small buffers.
// *@section page_iface_wl_shm_pool_api API
// *See @ref iface_wl_shm_pool.
//
//* *@defgroup iface_wl_shm_pool The wl_shm_pool interface
// * *The wl_shm_pool object encapsulates a piece of memory shared
// *between the compositor and client.  Through the wl_shm_pool
// *object, the client can allocate shared memory wl_buffer objects.
// *All objects created through the same pool share the same
// *underlying mapped memory. Reusing the mapped memory avoids the
// *setup/teardown overhead and is useful when interactively resizing
// *a surface or for many small buffers.
//
//* *@page page_iface_wl_shm wl_shm
// *@section page_iface_wl_shm_desc Description
// * *A singleton global object that provides support for shared
// *memory.
// * *Clients can create wl_shm_pool objects using the create_pool
// *request.
// * *On binding the wl_shm object one or more format events
// *are emitted to inform clients about the valid pixel formats
// *that can be used for buffers.
// *@section page_iface_wl_shm_api API
// *See @ref iface_wl_shm.
//
//* *@defgroup iface_wl_shm The wl_shm interface
// * *A singleton global object that provides support for shared
// *memory.
// * *Clients can create wl_shm_pool objects using the create_pool
// *request.
// * *On binding the wl_shm object one or more format events
// *are emitted to inform clients about the valid pixel formats
// *that can be used for buffers.
//
//* *@page page_iface_wl_buffer wl_buffer
// *@section page_iface_wl_buffer_desc Description
// * *A buffer provides the content for a C.wl_surface. Buffers are
// *created through factory interfaces such as wl_shm, wp_linux_buffer_params
// *(from the linux-dmabuf protocol extension) or similar. It has a width and
// *a height and can be attached to a C.wl_surface, but the mechanism by which a
// *client provides and updates the contents is defined by the buffer factory
// *interface.
// * *Color channels are assumed to be electrical rather than optical (in other
// *words, encoded with a transfer function) unless otherwise specified. If
// *the buffer uses a format that has an alpha channel, the alpha channel is
// *assumed to be premultiplied into the electrical color channel values
// *(after transfer function encoding) unless otherwise specified.
// * *Note, because wl_buffer objects are created from multiple independent
// *factory interfaces, the wl_buffer interface is frozen at version 1.
// *@section page_iface_wl_buffer_api API
// *See @ref iface_wl_buffer.
//
//* *@defgroup iface_wl_buffer The wl_buffer interface
// * *A buffer provides the content for a C.wl_surface. Buffers are
// *created through factory interfaces such as wl_shm, wp_linux_buffer_params
// *(from the linux-dmabuf protocol extension) or similar. It has a width and
// *a height and can be attached to a C.wl_surface, but the mechanism by which a
// *client provides and updates the contents is defined by the buffer factory
// *interface.
// * *Color channels are assumed to be electrical rather than optical (in other
// *words, encoded with a transfer function) unless otherwise specified. If
// *the buffer uses a format that has an alpha channel, the alpha channel is
// *assumed to be premultiplied into the electrical color channel values
// *(after transfer function encoding) unless otherwise specified.
// * *Note, because wl_buffer objects are created from multiple independent
// *factory interfaces, the wl_buffer interface is frozen at version 1.
//
//* *@page page_iface_C.wl_data_offer C.wl_data_offer
// *@section page_iface_C.wl_data_offer_desc Description
// * *A C.wl_data_offer represents a piece of data offered for transfer
// *by another client (the source client).  It is used by the
// *copy-and-paste and drag-and-drop mechanisms.  The offer
// *describes the different mime types that the data can be
// *converted to and provides the mechanism for transferring the
// *data directly from the source client.
// *@section page_iface_C.wl_data_offer_api API
// *See @ref iface_C.wl_data_offer.
//
//* *@defgroup iface_C.wl_data_offer The C.wl_data_offer interface
// * *A C.wl_data_offer represents a piece of data offered for transfer
// *by another client (the source client).  It is used by the
// *copy-and-paste and drag-and-drop mechanisms.  The offer
// *describes the different mime types that the data can be
// *converted to and provides the mechanism for transferring the
// *data directly from the source client.
//
//* *@page page_iface_wl_data_source wl_data_source
// *@section page_iface_wl_data_source_desc Description
// * *The wl_data_source object is the source side of a C.wl_data_offer.
// *It is created by the source client in a data transfer and
// *provides a way to describe the offered data and a way to respond
// *to requests to transfer the data.
// *@section page_iface_wl_data_source_api API
// *See @ref iface_wl_data_source.
//
//* *@defgroup iface_wl_data_source The wl_data_source interface
// * *The wl_data_source object is the source side of a C.wl_data_offer.
// *It is created by the source client in a data transfer and
// *provides a way to describe the offered data and a way to respond
// *to requests to transfer the data.
//
//* *@page page_iface_wl_data_device wl_data_device
// *@section page_iface_wl_data_device_desc Description
// * *There is one wl_data_device per seat which can be obtained
// *from the global wl_data_device_manager singleton.
// * *A wl_data_device provides access to inter-client data transfer
// *mechanisms such as copy-and-paste and drag-and-drop.
// *@section page_iface_wl_data_device_api API
// *See @ref iface_wl_data_device.
//
//* *@defgroup iface_wl_data_device The wl_data_device interface
// * *There is one wl_data_device per seat which can be obtained
// *from the global wl_data_device_manager singleton.
// * *A wl_data_device provides access to inter-client data transfer
// *mechanisms such as copy-and-paste and drag-and-drop.
//
//* *@page page_iface_wl_data_device_manager wl_data_device_manager
// *@section page_iface_wl_data_device_manager_desc Description
// * *The wl_data_device_manager is a singleton global object that
// *provides access to inter-client data transfer mechanisms such as
// *copy-and-paste and drag-and-drop.  These mechanisms are tied to
// *a wl_seat and this interface lets a client get a wl_data_device
// *corresponding to a wl_seat.
// * *Depending on the version bound, the objects created from the bound
// *wl_data_device_manager object will have different requirements for
// *functioning properly. See wl_data_source.set_actions,
// *C.wl_data_offer.accept and C.wl_data_offer.finish for details.
// *@section page_iface_wl_data_device_manager_api API
// *See @ref iface_wl_data_device_manager.
//
//* *@defgroup iface_wl_data_device_manager The wl_data_device_manager interface
// * *The wl_data_device_manager is a singleton global object that
// *provides access to inter-client data transfer mechanisms such as
// *copy-and-paste and drag-and-drop.  These mechanisms are tied to
// *a wl_seat and this interface lets a client get a wl_data_device
// *corresponding to a wl_seat.
// * *Depending on the version bound, the objects created from the bound
// *wl_data_device_manager object will have different requirements for
// *functioning properly. See wl_data_source.set_actions,
// *C.wl_data_offer.accept and C.wl_data_offer.finish for details.
//
//* *@page page_iface_wl_shell wl_shell
// *@section page_iface_wl_shell_desc Description
// * *This interface is implemented by servers that provide
// *desktop-style user interfaces.
// * *It allows clients to associate a wl_shell_surface with
// *a basic surface.
// * *Note! This protocol is deprecated and not intended for production use.
// *For desktop-style user interfaces, use xdg_shell. Compositors and clients
// *should not implement this interface.
// *@section page_iface_wl_shell_api API
// *See @ref iface_wl_shell.
//
//* *@defgroup iface_wl_shell The wl_shell interface
// * *This interface is implemented by servers that provide
// *desktop-style user interfaces.
// * *It allows clients to associate a wl_shell_surface with
// *a basic surface.
// * *Note! This protocol is deprecated and not intended for production use.
// *For desktop-style user interfaces, use xdg_shell. Compositors and clients
// *should not implement this interface.
//
//* *@page page_iface_wl_shell_surface wl_shell_surface
// *@section page_iface_wl_shell_surface_desc Description
// * *An interface that may be implemented by a C.wl_surface, for
// *implementations that provide a desktop-style user interface.
// * *It provides requests to treat surfaces like toplevel, fullscreen
// *or popup windows, move, resize or maximize them, associate
// *metadata like title and class, etc.
// * *On the server side the object is automatically destroyed when
// *the related C.wl_surface is destroyed. On the client side,
// *wl_shell_surface_destroy() must be called before destroying
// *the C.wl_surface object.
// *@section page_iface_wl_shell_surface_api API
// *See @ref iface_wl_shell_surface.
//
//* *@defgroup iface_wl_shell_surface The wl_shell_surface interface
// * *An interface that may be implemented by a C.wl_surface, for
// *implementations that provide a desktop-style user interface.
// * *It provides requests to treat surfaces like toplevel, fullscreen
// *or popup windows, move, resize or maximize them, associate
// *metadata like title and class, etc.
// * *On the server side the object is automatically destroyed when
// *the related C.wl_surface is destroyed. On the client side,
// *wl_shell_surface_destroy() must be called before destroying
// *the C.wl_surface object.
//
//* *@page page_iface_C.wl_surface wl_surface
// *@section page_iface_C.wl_surface_desc Description
// * *A surface is a rectangular area that may be displayed on zero
// *or more outputs, and shown any number of times at the compositor's
// *discretion. They can present wl_buffers, receive user input, and
// *define a local coordinate system.
// * *The size of a surface (and relative positions on it) is described
// *in surface-local coordinates, which may differ from the buffer
// *coordinates of the pixel content, in case a buffer_transform
// *or a buffer_scale is used.
// * *A surface without a "role" is fairly useless: a compositor does
// *not know where, when or how to present it. The role is the
// *purpose of a C.wl_surface. Examples of roles are a cursor for a
// *pointer (as set by C.wl_pointer.set_cursor), a drag icon
// *(wl_data_device.start_drag), a sub-surface
// *(wl_subcompositor.get_subsurface), and a window as defined by a
// *shell protocol (e.g. wl_shell.get_shell_surface).
// * *A surface can have only one role at a time. Initially a
// *C.wl_surface does not have a role. Once a wl_surface is given a
// *role, it is set permanently for the whole lifetime of the
// *C.wl_surface object. Giving the current role again is allowed,
// *unless explicitly forbidden by the relevant interface
// *specification.
// * *Surface roles are given by requests in other interfaces such as
// *C.wl_pointer.set_cursor. The request should explicitly mention
// *that this request gives a role to a C.wl_surface. Often, this
// *request also creates a new protocol object that represents the
// *role and adds additional functionality to C.wl_surface. When a
// *client wants to destroy a C.wl_surface, they must destroy this role
// *object before the C.wl_surface, otherwise a defunct_role_object error is
// *sent.
// * *Destroying the role object does not remove the role from the
// *C.wl_surface, but it may stop the wl_surface from "playing the role".
// *For instance, if a wl_subsurface object is destroyed, the C.wl_surface
// *it was created for will be unmapped and forget its position and
// *z-order. It is allowed to create a wl_subsurface for the same
// *C.wl_surface again, but it is not allowed to use the wl_surface as
// *a cursor (cursor is a different role than sub-surface, and role
// *switching is not allowed).
// *@section page_iface_C.wl_surface_api API
// *See @ref iface_C.wl_surface.
//
//* *@defgroup iface_C.wl_surface The wl_surface interface
// * *A surface is a rectangular area that may be displayed on zero
// *or more outputs, and shown any number of times at the compositor's
// *discretion. They can present wl_buffers, receive user input, and
// *define a local coordinate system.
// * *The size of a surface (and relative positions on it) is described
// *in surface-local coordinates, which may differ from the buffer
// *coordinates of the pixel content, in case a buffer_transform
// *or a buffer_scale is used.
// * *A surface without a "role" is fairly useless: a compositor does
// *not know where, when or how to present it. The role is the
// *purpose of a C.wl_surface. Examples of roles are a cursor for a
// *pointer (as set by C.wl_pointer.set_cursor), a drag icon
// *(wl_data_device.start_drag), a sub-surface
// *(wl_subcompositor.get_subsurface), and a window as defined by a
// *shell protocol (e.g. wl_shell.get_shell_surface).
// * *A surface can have only one role at a time. Initially a
// *C.wl_surface does not have a role. Once a wl_surface is given a
// *role, it is set permanently for the whole lifetime of the
// *C.wl_surface object. Giving the current role again is allowed,
// *unless explicitly forbidden by the relevant interface
// *specification.
// * *Surface roles are given by requests in other interfaces such as
// *C.wl_pointer.set_cursor. The request should explicitly mention
// *that this request gives a role to a C.wl_surface. Often, this
// *request also creates a new protocol object that represents the
// *role and adds additional functionality to C.wl_surface. When a
// *client wants to destroy a C.wl_surface, they must destroy this role
// *object before the C.wl_surface, otherwise a defunct_role_object error is
// *sent.
// * *Destroying the role object does not remove the role from the
// *C.wl_surface, but it may stop the wl_surface from "playing the role".
// *For instance, if a wl_subsurface object is destroyed, the C.wl_surface
// *it was created for will be unmapped and forget its position and
// *z-order. It is allowed to create a wl_subsurface for the same
// *C.wl_surface again, but it is not allowed to use the wl_surface as
// *a cursor (cursor is a different role than sub-surface, and role
// *switching is not allowed).
//
//* *@page page_iface_wl_seat wl_seat
// *@section page_iface_wl_seat_desc Description
// * *A seat is a group of keyboards, pointer and touch devices. This
// *object is published as a global during start up, or when such a
// *device is hot plugged.  A seat typically has a pointer and
// *maintains a keyboard focus and a pointer focus.
// *@section page_iface_wl_seat_api API
// *See @ref iface_wl_seat.
//
//* *@defgroup iface_wl_seat The wl_seat interface
// * *A seat is a group of keyboards, pointer and touch devices. This
// *object is published as a global during start up, or when such a
// *device is hot plugged.  A seat typically has a pointer and
// *maintains a keyboard focus and a pointer focus.
//
//* *@page page_iface_C.wl_pointer wl_pointer
// *@section page_iface_C.wl_pointer_desc Description
// * *The C.wl_pointer interface represents one or more input devices,
// *such as mice, which control the pointer location and pointer_focus
// *of a seat.
// * *The C.wl_pointer interface generates motion, enter and leave
// *events for the surfaces that the pointer is located over,
// *and button and axis events for button presses, button releases
// *and scrolling.
// *@section page_iface_C.wl_pointer_api API
// *See @ref iface_C.wl_pointer.
//
//* *@defgroup iface_C.wl_pointer The wl_pointer interface
// * *The C.wl_pointer interface represents one or more input devices,
// *such as mice, which control the pointer location and pointer_focus
// *of a seat.
// * *The C.wl_pointer interface generates motion, enter and leave
// *events for the surfaces that the pointer is located over,
// *and button and axis events for button presses, button releases
// *and scrolling.
//
//* *@page page_iface_wl_keyboard wl_keyboard
// *@section page_iface_wl_keyboard_desc Description
// * *The wl_keyboard interface represents one or more keyboards
// *associated with a seat.
// * *Each wl_keyboard has the following logical state:
// * *- an active surface (possibly null),
// *- the keys currently logically down,
// *- the active modifiers,
// *- the active group.
// * *By default, the active surface is null, the keys currently logically down
// *are empty, the active modifiers and the active group are 0.
// *@section page_iface_wl_keyboard_api API
// *See @ref iface_wl_keyboard.
//
//* *@defgroup iface_wl_keyboard The wl_keyboard interface
// * *The wl_keyboard interface represents one or more keyboards
// *associated with a seat.
// * *Each wl_keyboard has the following logical state:
// * *- an active surface (possibly null),
// *- the keys currently logically down,
// *- the active modifiers,
// *- the active group.
// * *By default, the active surface is null, the keys currently logically down
// *are empty, the active modifiers and the active group are 0.
//
//* *@page page_iface_wl_touch wl_touch
// *@section page_iface_wl_touch_desc Description
// * *The wl_touch interface represents a touchscreen
// *associated with a seat.
// * *Touch interactions can consist of one or more contacts.
// *For each contact, a series of events is generated, starting
// *with a down event, followed by zero or more motion events,
// *and ending with an up event. Events relating to the same
// *contact point can be identified by the ID of the sequence.
// *@section page_iface_wl_touch_api API
// *See @ref iface_wl_touch.
//
//* *@defgroup iface_wl_touch The wl_touch interface
// * *The wl_touch interface represents a touchscreen
// *associated with a seat.
// * *Touch interactions can consist of one or more contacts.
// *For each contact, a series of events is generated, starting
// *with a down event, followed by zero or more motion events,
// *and ending with an up event. Events relating to the same
// *contact point can be identified by the ID of the sequence.
//
//* *@page page_iface_wl_output wl_output
// *@section page_iface_wl_output_desc Description
// * *An output describes part of the compositor geometry.  The
// *compositor works in the 'compositor coordinate system' and an
// *output corresponds to a rectangular area in that space that is
// *actually visible.  This typically corresponds to a monitor that
// *displays part of the compositor space.  This object is published
// *as global during start up, or when a monitor is hotplugged.
// *@section page_iface_wl_output_api API
// *See @ref iface_wl_output.
//
//* *@defgroup iface_wl_output The wl_output interface
// * *An output describes part of the compositor geometry.  The
// *compositor works in the 'compositor coordinate system' and an
// *output corresponds to a rectangular area in that space that is
// *actually visible.  This typically corresponds to a monitor that
// *displays part of the compositor space.  This object is published
// *as global during start up, or when a monitor is hotplugged.
//
//* *@page page_iface_wl_region wl_region
// *@section page_iface_wl_region_desc Description
// * *A region object describes an area.
// * *Region objects are used to describe the opaque and input
// *regions of a surface.
// *@section page_iface_wl_region_api API
// *See @ref iface_wl_region.
//
//* *@defgroup iface_wl_region The wl_region interface
// * *A region object describes an area.
// * *Region objects are used to describe the opaque and input
// *regions of a surface.
//
//* *@page page_iface_wl_subcompositor wl_subcompositor
// *@section page_iface_wl_subcompositor_desc Description
// * *The global interface exposing sub-surface compositing capabilities.
// *A C.wl_surface, that has sub-surfaces associated, is called the
// *parent surface. Sub-surfaces can be arbitrarily nested and create
// *a tree of sub-surfaces.
// * *The root surface in a tree of sub-surfaces is the main
// *surface. The main surface cannot be a sub-surface, because
// *sub-surfaces must always have a parent.
// * *A main surface with its sub-surfaces forms a (compound) window.
// *For window management purposes, this set of C.wl_surface objects is
// *to be considered as a single window, and it should also behave as
// *such.
// * *The aim of sub-surfaces is to offload some of the compositing work
// *within a window from clients to the compositor. A prime example is
// *a video player with decorations and video in separate C.wl_surface
// *objects. This should allow the compositor to pass YUV video buffer
// *processing to dedicated overlay hardware when possible.
// *@section page_iface_wl_subcompositor_api API
// *See @ref iface_wl_subcompositor.
//
//* *@defgroup iface_wl_subcompositor The wl_subcompositor interface
// * *The global interface exposing sub-surface compositing capabilities.
// *A C.wl_surface, that has sub-surfaces associated, is called the
// *parent surface. Sub-surfaces can be arbitrarily nested and create
// *a tree of sub-surfaces.
// * *The root surface in a tree of sub-surfaces is the main
// *surface. The main surface cannot be a sub-surface, because
// *sub-surfaces must always have a parent.
// * *A main surface with its sub-surfaces forms a (compound) window.
// *For window management purposes, this set of C.wl_surface objects is
// *to be considered as a single window, and it should also behave as
// *such.
// * *The aim of sub-surfaces is to offload some of the compositing work
// *within a window from clients to the compositor. A prime example is
// *a video player with decorations and video in separate C.wl_surface
// *objects. This should allow the compositor to pass YUV video buffer
// *processing to dedicated overlay hardware when possible.
//
//* *@page page_iface_wl_subsurface wl_subsurface
// *@section page_iface_wl_subsurface_desc Description
// * *An additional interface to a C.wl_surface object, which has been
// *made a sub-surface. A sub-surface has one parent surface. A
// *sub-surface's size and position are not limited to that of the parent.
// *Particularly, a sub-surface is not automatically clipped to its
// *parent's area.
// * *A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
// *and the parent surface is mapped. The order of which one happens
// *first is irrelevant. A sub-surface is hidden if the parent becomes
// *hidden, or if a NULL wl_buffer is applied. These rules apply
// *recursively through the tree of surfaces.
// * *The behaviour of a C.wl_surface.commit request on a sub-surface
// *depends on the sub-surface's mode. The possible modes are
// *synchronized and desynchronized, see methods
// *wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
// *mode caches the C.wl_surface state to be applied when the parent's
// *state gets applied, and desynchronized mode applies the pending
// *C.wl_surface state directly. A sub-surface is initially in the
// *synchronized mode.
// * *Sub-surfaces also have another kind of state, which is managed by
// *wl_subsurface requests, as opposed to C.wl_surface requests. This
// *state includes the sub-surface position relative to the parent
// *surface (wl_subsurface.set_position), and the stacking order of
// *the parent and its sub-surfaces (wl_subsurface.place_above and
// *.place_below). This state is applied when the parent surface's
// *C.wl_surface state is applied, regardless of the sub-surface's mode.
// *As the exception, set_sync and set_desync are effective immediately.
// * *The main surface can be thought to be always in desynchronized mode,
// *since it does not have a parent in the sub-surfaces sense.
// * *Even if a sub-surface is in desynchronized mode, it will behave as
// *in synchronized mode, if its parent surface behaves as in
// *synchronized mode. This rule is applied recursively throughout the
// *tree of surfaces. This means, that one can set a sub-surface into
// *synchronized mode, and then assume that all its child and grand-child
// *sub-surfaces are synchronized, too, without explicitly setting them.
// * *Destroying a sub-surface takes effect immediately. If you need to
// *synchronize the removal of a sub-surface to the parent surface update,
// *unmap the sub-surface first by attaching a NULL wl_buffer, update parent,
// *and then destroy the sub-surface.
// * *If the parent C.wl_surface object is destroyed, the sub-surface is
// *unmapped.
// * *A sub-surface never has the keyboard focus of any seat.
// * *The C.wl_surface.offset request is ignored: clients must use set_position
// *instead to move the sub-surface.
// *@section page_iface_wl_subsurface_api API
// *See @ref iface_wl_subsurface.
//
//* *@defgroup iface_wl_subsurface The wl_subsurface interface
// * *An additional interface to a C.wl_surface object, which has been
// *made a sub-surface. A sub-surface has one parent surface. A
// *sub-surface's size and position are not limited to that of the parent.
// *Particularly, a sub-surface is not automatically clipped to its
// *parent's area.
// * *A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
// *and the parent surface is mapped. The order of which one happens
// *first is irrelevant. A sub-surface is hidden if the parent becomes
// *hidden, or if a NULL wl_buffer is applied. These rules apply
// *recursively through the tree of surfaces.
// * *The behaviour of a C.wl_surface.commit request on a sub-surface
// *depends on the sub-surface's mode. The possible modes are
// *synchronized and desynchronized, see methods
// *wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
// *mode caches the C.wl_surface state to be applied when the parent's
// *state gets applied, and desynchronized mode applies the pending
// *C.wl_surface state directly. A sub-surface is initially in the
// *synchronized mode.
// * *Sub-surfaces also have another kind of state, which is managed by
// *wl_subsurface requests, as opposed to C.wl_surface requests. This
// *state includes the sub-surface position relative to the parent
// *surface (wl_subsurface.set_position), and the stacking order of
// *the parent and its sub-surfaces (wl_subsurface.place_above and
// *.place_below). This state is applied when the parent surface's
// *C.wl_surface state is applied, regardless of the sub-surface's mode.
// *As the exception, set_sync and set_desync are effective immediately.
// * *The main surface can be thought to be always in desynchronized mode,
// *since it does not have a parent in the sub-surfaces sense.
// * *Even if a sub-surface is in desynchronized mode, it will behave as
// *in synchronized mode, if its parent surface behaves as in
// *synchronized mode. This rule is applied recursively throughout the
// *tree of surfaces. This means, that one can set a sub-surface into
// *synchronized mode, and then assume that all its child and grand-child
// *sub-surfaces are synchronized, too, without explicitly setting them.
// * *Destroying a sub-surface takes effect immediately. If you need to
// *synchronize the removal of a sub-surface to the parent surface update,
// *unmap the sub-surface first by attaching a NULL wl_buffer, update parent,
// *and then destroy the sub-surface.
// * *If the parent C.wl_surface object is destroyed, the sub-surface is
// *unmapped.
// * *A sub-surface never has the keyboard focus of any seat.
// * *The C.wl_surface.offset request is ignored: clients must use set_position
// *instead to move the sub-surface.
//
//* *@page page_iface_wl_fixes wl_fixes
// *@section page_iface_wl_fixes_desc Description
// * *This global fixes problems with other core-protocol interfaces that
// *cannot be fixed in these interfaces themselves.
// *@section page_iface_wl_fixes_api API
// *See @ref iface_wl_fixes.
//
//* *@defgroup iface_wl_fixes The wl_fixes interface
// * *This global fixes problems with other core-protocol interfaces that
// *cannot be fixed in these interfaces themselves.
//
//* *@ingroup iface_wl_display
// *global error values
// * *These errors are global and can be emitted in response to any
// *server request.
//
pub enum Wl_display_error {

//*	 *server couldn't find object
//
	wl_display_error_invalid_object = 0
//*	 *method doesn't exist on the specified interface or malformed request
//
	wl_display_error_invalid_method = 1
//*	 *server is out of memory
//
	wl_display_error_no_memory = 2
//*	 *implementation error in compositor
//
	wl_display_error_implementation = 3
}

// WL_DISPLAY_ERROR_ENUM
//* *@ingroup iface_wl_display
// *@struct wl_display_listener
//
struct C.wl_display_listener {
//*	 *fatal error event
//	 *	 *The error event is sent out when a fatal (non-recoverable)
//	 *error has occurred. The object_id argument is the object where
//	 *the error occurred, most often in response to a request to that
//	 *object. The code identifies the error and is defined by the
//	 *object interface. As such, each interface defines its own set of
//	 *error codes. The message is a brief description of the error,
//	 *for (debugging) convenience.
//	 *@param object_id object where the error occurred
//	 *@param code error code
//	 *@param message error description
//
	error fn (voidptr, &C.wl_display, voidptr, u32, &i8)
//*	 *acknowledge object ID deletion
//	 *	 *This event is used internally by the object ID management
//	 *logic. When a client deletes an object that it had created, the
//	 *server will send this event to acknowledge that it has seen the
//	 *delete request. When the client receives this event, it will
//	 *know that it can safely reuse the object ID.
//	 *@param id deleted object ID
//
	delete_id fn (voidptr, &C.wl_display, u32)
}
//* *@ingroup iface_wl_display
//
//* *@ingroup iface_wl_display
//
//* *@ingroup iface_wl_display
//
//* *@ingroup iface_wl_display
//
//* *@ingroup iface_wl_display
//
//*@ingroup iface_wl_display
//*@ingroup iface_wl_display
//* *@ingroup iface_wl_display
// * *The sync request asks the server to emit the 'done' event
// *on the returned wl_callback object.  Since requests are
// *handled in-order and events are delivered in-order, this can
// *be used as a barrier to ensure all previous requests and the
// *resulting events have been handled.
// * *The object returned by this request will be destroyed by the
// *compositor after the callback is fired and as such the client must not
// *attempt to use it after that point.
// * *The callback_data passed in the callback is undefined and should be ignored.
//
//* *@ingroup iface_wl_display
// * *This request creates a registry object that allows the client
// *to list and bind the global objects available from the
// *compositor.
// * *It should be noted that the server side resources consumed in
// *response to a get_registry request can only be released when the
// *client disconnects, not when the client side proxy is destroyed.
// *Therefore, clients should invoke get_registry as infrequently as
// *possible to avoid wasting memory.
//
//* *@ingroup iface_wl_registry
// *@struct wl_registry_listener
//
struct Wl_registry_listener {
//*	 *announce global object
//	 *	 *Notify the client of global objects.
//	 *	 *The event notifies the client that a global object with the
//	 *given name is now available, and it implements the given version
//	 *of the given interface.
//	 *@param name numeric name of the global object
//	 *@param interface interface implemented by the object
//	 *@param version interface version
//
	global fn (voidptr, &Wl_registry, u32, &i8, u32)
//*	 *announce removal of global object
//	 *	 *Notify the client of removed global objects.
//	 *	 *This event notifies the client that the global identified by
//	 *name is no longer available. If the client bound to the global
//	 *using the bind request, the client should now destroy that
//	 *object.
//	 *	 *The object remains valid and requests to the object will be
//	 *ignored until the client destroys it, to avoid races between the
//	 *global going away and a client sending a request to it.
//	 *@param name numeric name of the global object
//
	global_remove fn (voidptr, &Wl_registry, u32)
}
//* *@ingroup iface_wl_registry
//
//* *@ingroup iface_wl_registry
//
//* *@ingroup iface_wl_registry
//
//* *@ingroup iface_wl_registry
//
//*@ingroup iface_wl_registry
//*@ingroup iface_wl_registry
//*@ingroup iface_wl_registry
//* *@ingroup iface_wl_registry
// * *Binds a new, client-created object to the server using the
// *specified name as the identifier.
//
//* *@ingroup iface_wl_callback
// *@struct wl_callback_listener
//
struct Wl_callback_listener {
//*	 *done event
//	 *	 *Notify the client when the related request is done.
//	 *@param callback_data request-specific data for the callback
//
	done fn (voidptr, &Wl_callback, u32)
}
//* *@ingroup iface_wl_callback
//
//* *@ingroup iface_wl_callback
//
//*@ingroup iface_wl_callback
//*@ingroup iface_wl_callback
//*@ingroup iface_wl_callback
//* *@ingroup iface_wl_compositor
//
//* *@ingroup iface_wl_compositor
//
//*@ingroup iface_wl_compositor
//*@ingroup iface_wl_compositor
//*@ingroup iface_wl_compositor
//* *@ingroup iface_wl_compositor
// * *Ask the compositor to create a new surface.
//
//* *@ingroup iface_wl_compositor
// * *Ask the compositor to create a new region.
//
//* *@ingroup iface_wl_shm_pool
//
//* *@ingroup iface_wl_shm_pool
//
//* *@ingroup iface_wl_shm_pool
//
//*@ingroup iface_wl_shm_pool
//*@ingroup iface_wl_shm_pool
//* *@ingroup iface_wl_shm_pool
// * *Create a wl_buffer object from the pool.
// * *The buffer is created offset bytes into the pool and has
// *width and height as specified.  The stride argument specifies
// *the number of bytes from the beginning of one row to the beginning
// *of the next.  The format is the pixel format of the buffer and
// *must be one of those advertised through the wl_shm.format event.
// * *A buffer will keep a reference to the pool it was created from
// *so it is valid to destroy the pool immediately after creating
// *a buffer from it.
//
//* *@ingroup iface_wl_shm_pool
// * *Destroy the shared memory pool.
// * *The mmapped memory will be released when all
// *buffers that have been created from this pool
// *are gone.
//
//* *@ingroup iface_wl_shm_pool
// * *This request will cause the server to remap the backing memory
// *for the pool from the file descriptor passed when the pool was
// *created, but using the new size.  This request can only be
// *used to make the pool bigger.
// * *This request only changes the amount of bytes that are mmapped
// *by the server and does not touch the file corresponding to the
// *file descriptor passed at creation time. It is the client's
// *responsibility to ensure that the file is at least as big as
// *the new pool size.
//
//* *@ingroup iface_wl_shm
// *wl_shm error values
// * *These errors can be emitted in response to wl_shm requests.
//
pub enum Wl_shm_error {

//*	 *buffer format is not known
//
	wl_shm_error_invalid_format = 0
//*	 *invalid size or stride during pool or buffer creation
//
	wl_shm_error_invalid_stride = 1
//*	 *mmapping the file descriptor failed
//
	wl_shm_error_invalid_fd = 2
}

// WL_SHM_ERROR_ENUM
//* *@ingroup iface_wl_shm
// *pixel formats
// * *This describes the memory layout of an individual pixel.
// * *All renderers should support argb8888 and xrgb8888 but any other
// *formats are optional and may not be supported by the particular
// *renderer in use.
// * *The drm format codes match the macros defined in drm_fourcc.h, except
// *argb8888 and xrgb8888. The formats actually supported by the compositor
// *will be reported by the format event.
// * *For all wl_shm formats and unless specified in another protocol
// *extension, pre-multiplied alpha is used for pixel values.
//
pub enum Wl_shm_format {

//*	 *32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
//
	wl_shm_format_argb_8888 = 0
//*	 *32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
//
	wl_shm_format_xrgb_8888 = 1
//*	 *8-bit color index format, [7:0] C
//
	wl_shm_format_c8 = 538982467
//*	 *8-bit RGB format, [7:0] R:G:B 3:3:2
//
	wl_shm_format_rgb_332 = 943867730
//*	 *8-bit BGR format, [7:0] B:G:R 2:3:3
//
	wl_shm_format_bgr_233 = 944916290
//*	 *16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
//
	wl_shm_format_xrgb_4444 = 842093144
//*	 *16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
//
	wl_shm_format_xbgr_4444 = 842089048
//*	 *16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
//
	wl_shm_format_rgbx_4444 = 842094674
//*	 *16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
//
	wl_shm_format_bgrx_4444 = 842094658
//*	 *16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
//
	wl_shm_format_argb_4444 = 842093121
//*	 *16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
//
	wl_shm_format_abgr_4444 = 842089025
//*	 *16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
//
	wl_shm_format_rgba_4444 = 842088786
//*	 *16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
//
	wl_shm_format_bgra_4444 = 842088770
//*	 *16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
//
	wl_shm_format_xrgb_1555 = 892424792
//*	 *16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
//
	wl_shm_format_xbgr_1555 = 892420696
//*	 *16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
//
	wl_shm_format_rgbx_5551 = 892426322
//*	 *16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
//
	wl_shm_format_bgrx_5551 = 892426306
//*	 *16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
//
	wl_shm_format_argb_1555 = 892424769
//*	 *16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
//
	wl_shm_format_abgr_1555 = 892420673
//*	 *16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
//
	wl_shm_format_rgba_5551 = 892420434
//*	 *16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
//
	wl_shm_format_bgra_5551 = 892420418
//*	 *16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
//
	wl_shm_format_rgb_565 = 909199186
//*	 *16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
//
	wl_shm_format_bgr_565 = 909199170
//*	 *24-bit RGB format, [23:0] R:G:B little endian
//
	wl_shm_format_rgb_888 = 875710290
//*	 *24-bit BGR format, [23:0] B:G:R little endian
//
	wl_shm_format_bgr_888 = 875710274
//*	 *32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
//
	wl_shm_format_xbgr_8888 = 875709016
//*	 *32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
//
	wl_shm_format_rgbx_8888 = 875714642
//*	 *32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
//
	wl_shm_format_bgrx_8888 = 875714626
//*	 *32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
//
	wl_shm_format_abgr_8888 = 875708993
//*	 *32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
//
	wl_shm_format_rgba_8888 = 875708754
//*	 *32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
//
	wl_shm_format_bgra_8888 = 875708738
//*	 *32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
//
	wl_shm_format_xrgb_2101010 = 808669784
//*	 *32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
//
	wl_shm_format_xbgr_2101010 = 808665688
//*	 *32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
//
	wl_shm_format_rgbx_1010102 = 808671314
//*	 *32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
//
	wl_shm_format_bgrx_1010102 = 808671298
//*	 *32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
//
	wl_shm_format_argb_2101010 = 808669761
//*	 *32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
//
	wl_shm_format_abgr_2101010 = 808665665
//*	 *32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
//
	wl_shm_format_rgba_1010102 = 808665426
//*	 *32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
//
	wl_shm_format_bgra_1010102 = 808665410
//*	 *packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
//
	wl_shm_format_yuyv = 1448695129
//*	 *packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
//
	wl_shm_format_yvyu = 1431918169
//*	 *packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
//
	wl_shm_format_uyvy = 1498831189
//*	 *packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
//
	wl_shm_format_vyuy = 1498765654
//*	 *packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
//
	wl_shm_format_ayuv = 1448433985
//*	 *2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
//
	wl_shm_format_nv_12 = 842094158
//*	 *2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
//
	wl_shm_format_nv_21 = 825382478
//*	 *2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
//
	wl_shm_format_nv_16 = 909203022
//*	 *2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
//
	wl_shm_format_nv_61 = 825644622
//*	 *3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
//
	wl_shm_format_yuv_410 = 961959257
//*	 *3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
//
	wl_shm_format_yvu_410 = 961893977
//*	 *3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
//
	wl_shm_format_yuv_411 = 825316697
//*	 *3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
//
	wl_shm_format_yvu_411 = 825316953
//*	 *3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
//
	wl_shm_format_yuv_420 = 842093913
//*	 *3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
//
	wl_shm_format_yvu_420 = 842094169
//*	 *3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
//
	wl_shm_format_yuv_422 = 909202777
//*	 *3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
//
	wl_shm_format_yvu_422 = 909203033
//*	 *3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
//
	wl_shm_format_yuv_444 = 875713881
//*	 *3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
//
	wl_shm_format_yvu_444 = 875714137
//*	 *[7:0] R
//
	wl_shm_format_r8 = 538982482
//*	 *[15:0] R little endian
//
	wl_shm_format_r16 = 540422482
//*	 *[15:0] R:G 8:8 little endian
//
	wl_shm_format_rg_88 = 943212370
//*	 *[15:0] G:R 8:8 little endian
//
	wl_shm_format_gr_88 = 943215175
//*	 *[31:0] R:G 16:16 little endian
//
	wl_shm_format_rg_1616 = 842221394
//*	 *[31:0] G:R 16:16 little endian
//
	wl_shm_format_gr_1616 = 842224199
//*	 *[63:0] x:R:G:B 16:16:16:16 little endian
//
	wl_shm_format_xrgb_16161616_f = 1211388504
//*	 *[63:0] x:B:G:R 16:16:16:16 little endian
//
	wl_shm_format_xbgr_16161616_f = 1211384408
//*	 *[63:0] A:R:G:B 16:16:16:16 little endian
//
	wl_shm_format_argb_16161616_f = 1211388481
//*	 *[63:0] A:B:G:R 16:16:16:16 little endian
//
	wl_shm_format_abgr_16161616_f = 1211384385
//*	 *[31:0] X:Y:Cb:Cr 8:8:8:8 little endian
//
	wl_shm_format_xyuv_8888 = 1448434008
//*	 *[23:0] Cr:Cb:Y 8:8:8 little endian
//
	wl_shm_format_vuy_888 = 875713878
//*	 *Y followed by U then V, 10:10:10. Non-linear modifier only
//
	wl_shm_format_vuy_101010 = 808670550
//*	 *[63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels
//
	wl_shm_format_y210 = 808530521
//*	 *[63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels
//
	wl_shm_format_y212 = 842084953
//*	 *[63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels
//
	wl_shm_format_y216 = 909193817
//*	 *[31:0] A:Cr:Y:Cb 2:10:10:10 little endian
//
	wl_shm_format_y410 = 808531033
//*	 *[63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
//
	wl_shm_format_y412 = 842085465
//*	 *[63:0] A:Cr:Y:Cb 16:16:16:16 little endian
//
	wl_shm_format_y416 = 909194329
//*	 *[31:0] X:Cr:Y:Cb 2:10:10:10 little endian
//
	wl_shm_format_xvyu_2101010 = 808670808
//*	 *[63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
//
	wl_shm_format_xvyu_12_16161616 = 909334104
//*	 *[63:0] X:Cr:Y:Cb 16:16:16:16 little endian
//
	wl_shm_format_xvyu_16161616 = 942954072
//*	 *[63:0]   A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
//
	wl_shm_format_y0_l0 = 810299481
//*	 *[63:0]   X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0  1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
//
	wl_shm_format_x0_l0 = 810299480
//*	 *[63:0]   A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
//
	wl_shm_format_y0_l2 = 843853913
//*	 *[63:0]   X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0  1:1:10:10:10:1:1:10:10:10 little endian
//
	wl_shm_format_x0_l2 = 843853912
	wl_shm_format_yuv_420_8_bit = 942691673
	wl_shm_format_yuv_420_10_bit = 808539481
	wl_shm_format_xrgb_8888_a8 = 943805016
	wl_shm_format_xbgr_8888_a8 = 943800920
	wl_shm_format_rgbx_8888_a8 = 943806546
	wl_shm_format_bgrx_8888_a8 = 943806530
	wl_shm_format_rgb_888_a8 = 943798354
	wl_shm_format_bgr_888_a8 = 943798338
	wl_shm_format_rgb_565_a8 = 943797586
	wl_shm_format_bgr_565_a8 = 943797570
//*	 *non-subsampled Cr:Cb plane
//
	wl_shm_format_nv_24 = 875714126
//*	 *non-subsampled Cb:Cr plane
//
	wl_shm_format_nv_42 = 842290766
//*	 *2x1 subsampled Cr:Cb plane, 10 bit per channel
//
	wl_shm_format_p210 = 808530512
//*	 *2x2 subsampled Cr:Cb plane 10 bits per channel
//
	wl_shm_format_p010 = 808530000
//*	 *2x2 subsampled Cr:Cb plane 12 bits per channel
//
	wl_shm_format_p012 = 842084432
//*	 *2x2 subsampled Cr:Cb plane 16 bits per channel
//
	wl_shm_format_p016 = 909193296
//*	 *[63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian
//
	wl_shm_format_axbxgxrx_106106106106 = 808534593
//*	 *2x2 subsampled Cr:Cb plane
//
	wl_shm_format_nv_15 = 892425806
	wl_shm_format_q410 = 808531025
	wl_shm_format_q401 = 825242705
//*	 *[63:0] x:R:G:B 16:16:16:16 little endian
//
	wl_shm_format_xrgb_16161616 = 942953048
//*	 *[63:0] x:B:G:R 16:16:16:16 little endian
//
	wl_shm_format_xbgr_16161616 = 942948952
//*	 *[63:0] A:R:G:B 16:16:16:16 little endian
//
	wl_shm_format_argb_16161616 = 942953025
//*	 *[63:0] A:B:G:R 16:16:16:16 little endian
//
	wl_shm_format_abgr_16161616 = 942948929
//*	 *[7:0] C0:C1:C2:C3:C4:C5:C6:C7 1:1:1:1:1:1:1:1 eight pixels/byte
//
	wl_shm_format_c1 = 538980675
//*	 *[7:0] C0:C1:C2:C3 2:2:2:2 four pixels/byte
//
	wl_shm_format_c2 = 538980931
//*	 *[7:0] C0:C1 4:4 two pixels/byte
//
	wl_shm_format_c4 = 538981443
//*	 *[7:0] D0:D1:D2:D3:D4:D5:D6:D7 1:1:1:1:1:1:1:1 eight pixels/byte
//
	wl_shm_format_d1 = 538980676
//*	 *[7:0] D0:D1:D2:D3 2:2:2:2 four pixels/byte
//
	wl_shm_format_d2 = 538980932
//*	 *[7:0] D0:D1 4:4 two pixels/byte
//
	wl_shm_format_d4 = 538981444
//*	 *[7:0] D
//
	wl_shm_format_d8 = 538982468
//*	 *[7:0] R0:R1:R2:R3:R4:R5:R6:R7 1:1:1:1:1:1:1:1 eight pixels/byte
//
	wl_shm_format_r1 = 538980690
//*	 *[7:0] R0:R1:R2:R3 2:2:2:2 four pixels/byte
//
	wl_shm_format_r2 = 538980946
//*	 *[7:0] R0:R1 4:4 two pixels/byte
//
	wl_shm_format_r4 = 538981458
//*	 *[15:0] x:R 6:10 little endian
//
	wl_shm_format_r10 = 540029266
//*	 *[15:0] x:R 4:12 little endian
//
	wl_shm_format_r12 = 540160338
//*	 *[31:0] A:Cr:Cb:Y 8:8:8:8 little endian
//
	wl_shm_format_avuy_8888 = 1498764865
//*	 *[31:0] X:Cr:Cb:Y 8:8:8:8 little endian
//
	wl_shm_format_xvuy_8888 = 1498764888
//*	 *2x2 subsampled Cr:Cb plane 10 bits per channel packed
//
	wl_shm_format_p030 = 808661072
}

// WL_SHM_FORMAT_ENUM
//* *@ingroup iface_wl_shm
// *@struct wl_shm_listener
//
struct Wl_shm_listener {
//*	 *pixel format description
//	 *	 *Informs the client about a valid pixel format that can be used
//	 *for buffers. Known formats include argb8888 and xrgb8888.
//	 *@param format buffer pixel format
//
	format fn (voidptr, &C.wl_shm, u32)
}
//* *@ingroup iface_wl_shm
//
//* *@ingroup iface_wl_shm
//
//* *@ingroup iface_wl_shm
//
//* *@ingroup iface_wl_shm
//
//*@ingroup iface_wl_shm
//*@ingroup iface_wl_shm
//*@ingroup iface_wl_shm
//* *@ingroup iface_wl_shm
// * *Create a new wl_shm_pool object.
// * *The pool can be used to create shared memory based buffer
// *objects.  The server will mmap size bytes of the passed file
// *descriptor, to use as backing memory for the pool.
//
//* *@ingroup iface_wl_shm
// * *Using this request a client can tell the server that it is not going to
// *use the shm object anymore.
// * *Objects created via this interface remain unaffected.
//
//* *@ingroup iface_wl_buffer
// *@struct wl_buffer_listener
//
struct C.wl_buffer_listener {
//*	 *compositor releases buffer
//	 *	 *Sent when this wl_buffer is no longer used by the compositor.
//	 *	 *For more information on when release events may or may not be
//	 *sent, and what consequences it has, please see the description
//	 *of C.wl_surface.attach.
//	 *	 *If a client receives a release event before the frame callback
//	 *requested in the same C.wl_surface.commit that attaches this
//	 *wl_buffer to a surface, then the client is immediately free to
//	 *reuse the buffer and its backing storage, and does not need a
//	 *second buffer for the next surface content update. Typically
//	 *this is possible, when the compositor maintains a copy of the
//	 *C.wl_surface contents, e.g. as a GL texture. This is an important
//	 *optimization for GL(ES) compositors with wl_shm clients.
//
	release fn (voidptr, &C.wl_buffer)
}
//* *@ingroup iface_wl_buffer
//
//* *@ingroup iface_wl_buffer
//
//* *@ingroup iface_wl_buffer
//
//*@ingroup iface_wl_buffer
//*@ingroup iface_wl_buffer
//* *@ingroup iface_wl_buffer
// * *Destroy a buffer. If and how you need to release the backing
// *storage is defined by the buffer factory interface.
// * *For possible side-effects to a surface, see C.wl_surface.attach.
//
enum C.wl_data_offer_error {
//*	 *finish request was called untimely
//
	C.wl_data_offer_error_invalid_finish = 0
//*	 *action mask contains invalid values
//
	C.wl_data_offer_error_invalid_action_mask = 1
//*	 *action argument has an invalid value
//
	C.wl_data_offer_error_invalid_action = 2
//*	 *offer doesn't accept this request
//
	C.wl_data_offer_error_invalid_offer = 3
}

// C.wl_data_offer_ERROR_ENUM
//* *@ingroup iface_C.wl_data_offer
// *@struct C.wl_data_offer_listener
//
struct C.wl_data_offer_listener {
//*	 *advertise offered mime type
//	 *	 *Sent immediately after creating the C.wl_data_offer object. One
//	 *event per offered mime type.
//	 *@param mime_type offered mime type
//
	offer fn (voidptr, &C.wl_data_offer, &i8)
//*	 *notify the source-side available actions
//	 *	 *This event indicates the actions offered by the data source.
//	 *It will be sent immediately after creating the C.wl_data_offer
//	 *object, or anytime the source side changes its offered actions
//	 *through wl_data_source.set_actions.
//	 *@param source_actions actions offered by the data source
//	 *@since 3
//
	source_actions fn (voidptr, &C.wl_data_offer, u32)
//*	 *notify the selected action
//	 *	 *This event indicates the action selected by the compositor
//	 *after matching the source/destination side actions. Only one
//	 *action (or none) will be offered here.
//	 *	 *This event can be emitted multiple times during the
//	 *drag-and-drop operation in response to destination side action
//	 *changes through C.wl_data_offer.set_actions.
//	 *	 *This event will no longer be emitted after wl_data_device.drop
//	 *happened on the drag-and-drop destination, the client must honor
//	 *the last action received, or the last preferred one set through
//	 *C.wl_data_offer.set_actions when handling an "ask" action.
//	 *	 *Compositors may also change the selected action on the fly,
//	 *mainly in response to keyboard modifier changes during the
//	 *drag-and-drop operation.
//	 *	 *The most recent action received is always the valid one. Prior
//	 *to receiving wl_data_device.drop, the chosen action may change
//	 *(e.g. due to keyboard modifiers being pressed). At the time of
//	 *receiving wl_data_device.drop the drag-and-drop destination must
//	 *honor the last action received.
//	 *	 *Action changes may still happen after wl_data_device.drop,
//	 *especially on "ask" actions, where the drag-and-drop destination
//	 *may choose another action afterwards. Action changes happening
//	 *at this stage are always the result of inter-client negotiation,
//	 *the compositor shall no longer be able to induce a different
//	 *action.
//	 *	 *Upon "ask" actions, it is expected that the drag-and-drop
//	 *destination may potentially choose a different action and/or
//	 *mime type, based on C.wl_data_offer.source_actions and finally
//	 *chosen by the user (e.g. popping up a menu with the available
//	 *options). The final C.wl_data_offer.set_actions and
//	 *C.wl_data_offer.accept requests must happen before the call to
//	 *C.wl_data_offer.finish.
//	 *@param dnd_action action selected by the compositor
//	 *@since 3
//
	action fn (voidptr, &C.wl_data_offer, u32)
}
//* *@ingroup iface_C.wl_data_offer
//
//* *@ingroup iface_C.wl_data_offer
//
//* *@ingroup iface_C.wl_data_offer
//
//* *@ingroup iface_C.wl_data_offer
//
//* *@ingroup iface_C.wl_data_offer
//
//* *@ingroup iface_C.wl_data_offer
//
//* *@ingroup iface_C.wl_data_offer
//
//* *@ingroup iface_C.wl_data_offer
//
//* *@ingroup iface_C.wl_data_offer
//
//*@ingroup iface_C.wl_data_offer
//*@ingroup iface_C.wl_data_offer
//* *@ingroup iface_C.wl_data_offer
// * *Indicate that the client can accept the given mime type, or
// *NULL for not accepted.
// * *For objects of version 2 or older, this request is used by the
// *client to give feedback whether the client can receive the given
// *mime type, or NULL if none is accepted; the feedback does not
// *determine whether the drag-and-drop operation succeeds or not.
// * *For objects of version 3 or newer, this request determines the
// *final result of the drag-and-drop operation. If the end result
// *is that no mime types were accepted, the drag-and-drop operation
// *will be cancelled and the corresponding drag source will receive
// *wl_data_source.cancelled. Clients may still use this event in
// *conjunction with wl_data_source.action for feedback.
//
//* *@ingroup iface_C.wl_data_offer
// * *To transfer the offered data, the client issues this request
// *and indicates the mime type it wants to receive.  The transfer
// *happens through the passed file descriptor (typically created
// *with the pipe system call).  The source client writes the data
// *in the mime type representation requested and then closes the
// *file descriptor.
// * *The receiving client reads from the read end of the pipe until
// *EOF and then closes its end, at which point the transfer is
// *complete.
// * *This request may happen multiple times for different mime types,
// *both before and after wl_data_device.drop. Drag-and-drop destination
// *clients may preemptively fetch data or examine it more closely to
// *determine acceptance.
//
//* *@ingroup iface_C.wl_data_offer
// * *Destroy the data offer.
//
//* *@ingroup iface_C.wl_data_offer
// * *Notifies the compositor that the drag destination successfully
// *finished the drag-and-drop operation.
// * *Upon receiving this request, the compositor will emit
// *wl_data_source.dnd_finished on the drag source client.
// * *It is a client error to perform other requests than
// *C.wl_data_offer.destroy after this one. It is also an error to perform
// *this request after a NULL mime type has been set in
// *C.wl_data_offer.accept or no action was received through
// *C.wl_data_offer.action.
// * *If C.wl_data_offer.finish request is received for a non drag and drop
// *operation, the invalid_finish protocol error is raised.
//
//* *@ingroup iface_C.wl_data_offer
// * *Sets the actions that the destination side client supports for
// *this operation. This request may trigger the emission of
// *wl_data_source.action and C.wl_data_offer.action events if the compositor
// *needs to change the selected action.
// * *This request can be called multiple times throughout the
// *drag-and-drop operation, typically in response to wl_data_device.enter
// *or wl_data_device.motion events.
// * *This request determines the final result of the drag-and-drop
// *operation. If the end result is that no action is accepted,
// *the drag source will receive wl_data_source.cancelled.
// * *The dnd_actions argument must contain only values expressed in the
// *wl_data_device_manager.dnd_actions enum, and the preferred_action
// *argument must only contain one of those values set, otherwise it
// *will result in a protocol error.
// * *While managing an "ask" action, the destination drag-and-drop client
// *may perform further C.wl_data_offer.receive requests, and is expected
// *to perform one last C.wl_data_offer.set_actions request with a preferred
// *action other than "ask" (and optionally C.wl_data_offer.accept) before
// *requesting C.wl_data_offer.finish, in order to convey the action selected
// *by the user. If the preferred action is not in the
// *C.wl_data_offer.source_actions mask, an error will be raised.
// * *If the "ask" action is dismissed (e.g. user cancellation), the client
// *is expected to perform C.wl_data_offer.destroy right away.
// * *This request can only be made on drag-and-drop offers, a protocol error
// *will be raised otherwise.
//
pub enum Wl_data_source_error {
//*	 *action mask contains invalid values
//
	wl_data_source_error_invalid_action_mask = 0
//*	 *source doesn't accept this request
//
	wl_data_source_error_invalid_source = 1
}

// WL_DATA_SOURCE_ERROR_ENUM
//* *@ingroup iface_wl_data_source
// *@struct wl_data_source_listener
//
struct Wl_data_source_listener {
//*	 *a target accepts an offered mime type
//	 *	 *Sent when a target accepts pointer_focus or motion events. If
//	 *a target does not accept any of the offered types, type is NULL.
//	 *	 *Used for feedback during drag-and-drop.
//	 *@param mime_type mime type accepted by the target
//
	target fn (voidptr, &C.wl_data_source, &i8)
//*	 *send the data
//	 *	 *Request for data from the client. Send the data as the
//	 *specified mime type over the passed file descriptor, then close
//	 *it.
//	 *@param mime_type mime type for the data
//	 *@param fd file descriptor for the data
//
	send fn (voidptr, &C.wl_data_source, &i8, int)
//*	 *selection was cancelled
//	 *	 *This data source is no longer valid. There are several reasons
//	 *why this could happen:
//	 *	 *- The data source has been replaced by another data source. -
//	 *The drag-and-drop operation was performed, but the drop
//	 *destination did not accept any of the mime types offered through
//	 *C.wl_data_source.target. - The drag-and-drop operation was
//	 *performed, but the drop destination did not select any of the
//	 *actions present in the mask offered through
//	 *C.wl_data_source.action. - The drag-and-drop operation was
//	 *performed but didn't happen over a surface. - The compositor
//	 *cancelled the drag-and-drop operation (e.g. compositor dependent
//	 *timeouts to avoid stale drag-and-drop transfers).
//	 *	 *The client should clean up and destroy this data source.
//	 *	 *For objects of version 2 or older, C.wl_data_source.cancelled will
//	 *only be emitted if the data source was replaced by another data
//	 *source.
//
	cancelled fn (voidptr, &C.wl_data_source)
//*	 *the drag-and-drop operation physically finished
//	 *	 *The user performed the drop action. This event does not
//	 *indicate acceptance, C.wl_data_source.cancelled may still be
//	 *emitted afterwards if the drop destination does not accept any
//	 *mime type.
//	 *	 *However, this event might however not be received if the
//	 *compositor cancelled the drag-and-drop operation before this
//	 *event could happen.
//	 *	 *Note that the data_source may still be used in the future and
//	 *should not be destroyed here.
//	 *@since 3
//
	dnd_drop_performed fn (voidptr, &C.wl_data_source)
//*	 *the drag-and-drop operation concluded
//	 *	 *The drop destination finished interoperating with this data
//	 *source, so the client is now free to destroy this data source
//	 *and free all associated data.
//	 *	 *If the action used to perform the operation was "move", the
//	 *source can now delete the transferred data.
//	 *@since 3
//
	dnd_finished fn (voidptr, &C.wl_data_source)
//*	 *notify the selected action
//	 *	 *This event indicates the action selected by the compositor
//	 *after matching the source/destination side actions. Only one
//	 *action (or none) will be offered here.
//	 *	 *This event can be emitted multiple times during the
//	 *drag-and-drop operation, mainly in response to destination side
//	 *changes through C.wl_data_offer.set_actions, and as the data
//	 *device enters/leaves surfaces.
//	 *	 *It is only possible to receive this event after
//	 *wl_data_source.dnd_drop_performed if the drag-and-drop operation
//	 *ended in an "ask" action, in which case the final
//	 *wl_data_source.action event will happen immediately before
//	 *wl_data_source.dnd_finished.
//	 *	 *Compositors may also change the selected action on the fly,
//	 *mainly in response to keyboard modifier changes during the
//	 *drag-and-drop operation.
//	 *	 *The most recent action received is always the valid one. The
//	 *chosen action may change alongside negotiation (e.g. an "ask"
//	 *action can turn into a "move" operation), so the effects of the
//	 *final action must always be applied in
//	 *C.wl_data_offer.dnd_finished.
//	 *	 *Clients can trigger cursor surface changes from this point, so
//	 *they reflect the current action.
//	 *@param dnd_action action selected by the compositor
//	 *@since 3
//
	action fn (voidptr, &C.wl_data_source, u32)
}
//* *@ingroup iface_wl_data_source
//
//* *@ingroup iface_wl_data_source
//
//* *@ingroup iface_wl_data_source
//
//* *@ingroup iface_wl_data_source
//
//* *@ingroup iface_wl_data_source
//
//* *@ingroup iface_wl_data_source
//
//* *@ingroup iface_wl_data_source
//
//* *@ingroup iface_wl_data_source
//
//* *@ingroup iface_wl_data_source
//
//* *@ingroup iface_wl_data_source
//
//*@ingroup iface_wl_data_source
//*@ingroup iface_wl_data_source
//* *@ingroup iface_wl_data_source
// * *This request adds a mime type to the set of mime types
// *advertised to targets.  Can be called several times to offer
// *multiple types.
//
//* *@ingroup iface_wl_data_source
// * *Destroy the data source.
//
//* *@ingroup iface_wl_data_source
// * *Sets the actions that the source side client supports for this
// *operation. This request may trigger wl_data_source.action and
// *C.wl_data_offer.action events if the compositor needs to change the
// *selected action.
// * *The dnd_actions argument must contain only values expressed in the
// *wl_data_device_manager.dnd_actions enum, otherwise it will result
// *in a protocol error.
// * *This request must be made once only, and can only be made on sources
// *used in drag-and-drop, so it must be performed before
// *wl_data_device.start_drag. Attempting to use the source other than
// *for drag-and-drop will raise a protocol error.
//
pub enum Wl_data_device_error {
//*	 *given C.wl_surface has another role
//
	wl_data_device_error_role = 0
//*	 *source has already been used
//
	wl_data_device_error_used_source = 1
}

// WL_DATA_DEVICE_ERROR_ENUM
//* *@ingroup iface_wl_data_device
// *@struct wl_data_device_listener
//
struct Wl_data_device_listener {
//*	 *introduce a new C.wl_data_offer
//	 *	 *The data_offer event introduces a new C.wl_data_offer object,
//	 *which will subsequently be used in either the data_device.enter
//	 *event (for drag-and-drop) or the data_device.selection event
//	 *(for selections). Immediately following the
//	 *data_device.data_offer event, the new data_offer object will
//	 *send out data_offer.offer events to describe the mime types it
//	 *offers.
//	 *@param id the new data_offer object
//
	data_offer fn (voidptr, &C.wl_data_device, &C.C.wl_data_offer)
//*	 *initiate drag-and-drop session
//	 *	 *This event is sent when an active drag-and-drop pointer enters
//	 *a surface owned by the client. The position of the pointer at
//	 *enter time is provided by the x and y arguments, in
//	 *surface-local coordinates.
//	 *@param serial serial number of the enter event
//	 *@param surface client surface entered
//	 *@param x surface-local x coordinate
//	 *@param y surface-local y coordinate
//	 *@param id source data_offer object
//
	enter fn (voidptr, &Wl_data_device, u32, &C.wl_surface, Wl_int, Wl_int, &C.wl_data_offer)
//*	 *end drag-and-drop session
//	 *	 *This event is sent when the drag-and-drop pointer leaves the
//	 *surface and the session ends. The client must destroy the
//	 *C.wl_data_offer introduced at enter time at this point.
//
	leave fn (voidptr, &C.wl_data_device)
//*	 *drag-and-drop session motion
//	 *	 *This event is sent when the drag-and-drop pointer moves within
//	 *the currently focused surface. The new position of the pointer
//	 *is provided by the x and y arguments, in surface-local
//	 *coordinates.
//	 *@param time timestamp with millisecond granularity
//	 *@param x surface-local x coordinate
//	 *@param y surface-local y coordinate
//
	motion fn (voidptr, &C.wl_data_device, u32, Wl_int, Wl_int)
//*	 *end drag-and-drop session successfully
//	 *	 *The event is sent when a drag-and-drop operation is ended
//	 *because the implicit grab is removed.
//	 *	 *The drag-and-drop destination is expected to honor the last
//	 *action received through C.wl_data_offer.action, if the resulting
//	 *action is "copy" or "move", the destination can still perform
//	 *C.wl_data_offer.receive requests, and is expected to end all
//	 *transfers with a C.wl_data_offer.finish request.
//	 *	 *If the resulting action is "ask", the action will not be
//	 *considered final. The drag-and-drop destination is expected to
//	 *perform one last C.wl_data_offer.set_actions request, or
//	 *C.wl_data_offer.destroy in order to cancel the operation.
//
	drop fn (voidptr, &C.wl_data_device)
//*	 *advertise new selection
//	 *	 *The selection event is sent out to notify the client of a new
//	 *C.wl_data_offer for the selection for this device. The
//	 *data_device.data_offer and the data_offer.offer events are sent
//	 *out immediately before this event to introduce the data offer
//	 *object. The selection event is sent to a client immediately
//	 *before receiving keyboard focus and when a new selection is set
//	 *while the client has keyboard focus. The data_offer is valid
//	 *until a new data_offer or NULL is received or until the client
//	 *loses keyboard focus. Switching surface with keyboard focus
//	 *within the same client doesn't mean a new selection will be
//	 *sent. The client must destroy the previous selection data_offer,
//	 *if any, upon receiving this event.
//	 *@param id selection data_offer object
//
	selection fn (voidptr, &C.wl_data_device, &C.C.wl_data_offer)
}
//* *@ingroup iface_wl_data_device
//
//* *@ingroup iface_wl_data_device
//
//* *@ingroup iface_wl_data_device
//
//* *@ingroup iface_wl_data_device
//
//* *@ingroup iface_wl_data_device
//
//* *@ingroup iface_wl_data_device
//
//* *@ingroup iface_wl_data_device
//
//* *@ingroup iface_wl_data_device
//
//* *@ingroup iface_wl_data_device
//
//* *@ingroup iface_wl_data_device
//
//*@ingroup iface_wl_data_device
//*@ingroup iface_wl_data_device
//*@ingroup iface_wl_data_device
//* *@ingroup iface_wl_data_device
// * *This request asks the compositor to start a drag-and-drop
// *operation on behalf of the client.
// * *The source argument is the data source that provides the data
// *for the eventual data transfer. If source is NULL, enter, leave
// *and motion events are sent only to the client that initiated the
// *drag and the client is expected to handle the data passing
// *internally. If source is destroyed, the drag-and-drop session will be
// *cancelled.
// * *The origin surface is the surface where the drag originates and
// *the client must have an active implicit grab that matches the
// *serial.
// * *The icon surface is an optional (can be NULL) surface that
// *provides an icon to be moved around with the cursor.  Initially,
// *the top-left corner of the icon surface is placed at the cursor
// *hotspot, but subsequent C.wl_surface.offset requests can move the
// *relative position. Attach requests must be confirmed with
// *C.wl_surface.commit as usual. The icon surface is given the role of
// *a drag-and-drop icon. If the icon surface already has another role,
// *it raises a protocol error.
// * *The input region is ignored for C.wl_surfaces with the role of a
// *drag-and-drop icon.
// * *The given source may not be used in any further set_selection or
// *start_drag requests. Attempting to reuse a previously-used source
// *may send a used_source error.
//
//* *@ingroup iface_wl_data_device
// * *This request asks the compositor to set the selection
// *to the data from the source on behalf of the client.
// * *To unset the selection, set the source to NULL.
// * *The given source may not be used in any further set_selection or
// *start_drag requests. Attempting to reuse a previously-used source
// *may send a used_source error.
//
//* *@ingroup iface_wl_data_device
// * *This request destroys the data device.
//
//* *@ingroup iface_wl_data_device_manager
// *drag and drop actions
// * *This is a bitmask of the available/preferred actions in a
// *drag-and-drop operation.
// * *In the compositor, the selected action is a result of matching the
// *actions offered by the source and destination sides.  "action" events
// *with a "none" action will be sent to both source and destination if
// *there is no match. All further checks will effectively happen on
// *(source actions â© destination actions).
// * *In addition, compositors may also pick different actions in
// *reaction to key modifiers being pressed. One common design that
// *is used in major toolkits (and the behavior recommended for
// *compositors) is:
// * *- If no modifiers are pressed, the first match (in bit order)
// *will be used.
// *- Pressing Shift selects "move", if enabled in the mask.
// *- Pressing Control selects "copy", if enabled in the mask.
// * *Behavior beyond that is considered implementation-dependent.
// *Compositors may for example bind other modifiers (like Alt/Meta)
// *or drags initiated with other buttons than BTN_LEFT to specific
// *actions (e.g. "ask").
//
pub enum Wl_data_device_manager_dnd_action {

//*	 *no action
//
	wl_data_device_manager_dnd_action_none = 0
//*	 *copy action
//
	wl_data_device_manager_dnd_action_copy = 1
//*	 *move action
//
	wl_data_device_manager_dnd_action_move = 2
//*	 *ask action
//
	wl_data_device_manager_dnd_action_ask = 4
}

// WL_DATA_DEVICE_MANAGER_DND_ACTION_ENUM
//* *@ingroup iface_wl_data_device_manager
//
//* *@ingroup iface_wl_data_device_manager
//
//*@ingroup iface_wl_data_device_manager
//*@ingroup iface_wl_data_device_manager
//*@ingroup iface_wl_data_device_manager
//* *@ingroup iface_wl_data_device_manager
// * *Create a new data source.
//
//* *@ingroup iface_wl_data_device_manager
// * *Create a new data device for a given seat.
//
pub enum Wl_shell_error {
//*	 *given C.wl_surface has another role
//
	wl_shell_error_role = 0
}

// WL_SHELL_ERROR_ENUM
//* *@ingroup iface_wl_shell
//
//*@ingroup iface_wl_shell
//*@ingroup iface_wl_shell
//*@ingroup iface_wl_shell
//* *@ingroup iface_wl_shell
// * *Create a shell surface for an existing surface. This gives
// *the C.wl_surface the role of a shell surface. If the wl_surface
// *already has another role, it raises a protocol error.
// * *Only one shell surface can be associated with a given surface.
//
//* *@ingroup iface_wl_shell_surface
// *edge values for resizing
// * *These values are used to indicate which edge of a surface
// *is being dragged in a resize operation. The server may
// *use this information to adapt its behavior, e.g. choose
// *an appropriate cursor image.
//
pub enum Wl_shell_surface_resize {

//*	 *no edge
//
	wl_shell_surface_resize_none = 0
//*	 *top edge
//
	wl_shell_surface_resize_top = 1
//*	 *bottom edge
//
	wl_shell_surface_resize_bottom = 2
//*	 *left edge
//
	wl_shell_surface_resize_left = 4
//*	 *top and left edges
//
	wl_shell_surface_resize_top_left = 5
//*	 *bottom and left edges
//
	wl_shell_surface_resize_bottom_left = 6
//*	 *right edge
//
	wl_shell_surface_resize_right = 8
//*	 *top and right edges
//
	wl_shell_surface_resize_top_right = 9
//*	 *bottom and right edges
//
	wl_shell_surface_resize_bottom_right = 10
}

// WL_SHELL_SURFACE_RESIZE_ENUM
//* *@ingroup iface_wl_shell_surface
// *details of transient behaviour
// * *These flags specify details of the expected behaviour
// *of transient surfaces. Used in the set_transient request.
//
pub enum Wl_shell_surface_transient {

//*	 *do not set keyboard focus
//
	wl_shell_surface_transient_inactive = 1
}

// WL_SHELL_SURFACE_TRANSIENT_ENUM
//* *@ingroup iface_wl_shell_surface
// *different method to set the surface fullscreen
// * *Hints to indicate to the compositor how to deal with a conflict
// *between the dimensions of the surface and the dimensions of the
// *output. The compositor is free to ignore this parameter.
//
pub enum Wl_shell_surface_fullscreen_method {

//*	 *no preference, apply default policy
//
	wl_shell_surface_fullscreen_method_default = 0
//*	 *scale, preserve the surface's aspect ratio and center on output
//
	wl_shell_surface_fullscreen_method_scale = 1
//*	 *switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
//
	wl_shell_surface_fullscreen_method_driver = 2
//*	 *no upscaling, center on output and add black borders to compensate size mismatch
//
	wl_shell_surface_fullscreen_method_fill = 3
}

// WL_SHELL_SURFACE_FULLSCREEN_METHOD_ENUM
//* *@ingroup iface_wl_shell_surface
// *@struct wl_shell_surface_listener
//
struct Wl_shell_surface_listener {
//*	 *ping client
//	 *	 *Ping a client to check if it is receiving events and sending
//	 *requests. A client is expected to reply with a pong request.
//	 *@param serial serial number of the ping
//
	ping fn (voidptr, &C.wl_shell_surface, u32)
//*	 *suggest resize
//	 *	 *The configure event asks the client to resize its surface.
//	 *	 *The size is a hint, in the sense that the client is free to
//	 *ignore it if it doesn't resize, pick a smaller size (to satisfy
//	 *aspect ratio or resize in steps of NxM pixels).
//	 *	 *The edges parameter provides a hint about how the surface was
//	 *resized. The client may use this information to decide how to
//	 *adjust its content to the new size (e.g. a scrolling area might
//	 *adjust its content position to leave the viewable content
//	 *unmoved).
//	 *	 *The client is free to dismiss all but the last configure event
//	 *it received.
//	 *	 *The width and height arguments specify the size of the window in
//	 *surface-local coordinates.
//	 *@param edges how the surface was resized
//	 *@param width new width of the surface
//	 *@param height new height of the surface
//
	configure fn (voidptr, &C.wl_shell_surface, u32, int, int)
//*	 *popup interaction is done
//	 *	 *The popup_done event is sent out when a popup grab is broken,
//	 *that is, when the user clicks a surface that doesn't belong to
//	 *the client owning the popup surface.
//
	popup_done fn (voidptr, &C.wl_shell_surface)
}
//* *@ingroup iface_wl_shell_surface
//
//* *@ingroup iface_wl_shell_surface
//
//* *@ingroup iface_wl_shell_surface
//
//* *@ingroup iface_wl_shell_surface
//
//* *@ingroup iface_wl_shell_surface
//
//* *@ingroup iface_wl_shell_surface
//
//* *@ingroup iface_wl_shell_surface
//
//* *@ingroup iface_wl_shell_surface
//
//* *@ingroup iface_wl_shell_surface
//
//* *@ingroup iface_wl_shell_surface
//
//* *@ingroup iface_wl_shell_surface
//
//* *@ingroup iface_wl_shell_surface
//
//* *@ingroup iface_wl_shell_surface
//
//* *@ingroup iface_wl_shell_surface
//
//*@ingroup iface_wl_shell_surface
//*@ingroup iface_wl_shell_surface
//*@ingroup iface_wl_shell_surface
//* *@ingroup iface_wl_shell_surface
// * *A client must respond to a ping event with a pong request or
// *the client may be deemed unresponsive.
//
//* *@ingroup iface_wl_shell_surface
// * *Start a pointer-driven move of the surface.
// * *This request must be used in response to a button press event.
// *The server may ignore move requests depending on the state of
// *the surface (e.g. fullscreen or maximized).
//
//* *@ingroup iface_wl_shell_surface
// * *Start a pointer-driven resizing of the surface.
// * *This request must be used in response to a button press event.
// *The server may ignore resize requests depending on the state of
// *the surface (e.g. fullscreen or maximized).
//
//* *@ingroup iface_wl_shell_surface
// * *Map the surface as a toplevel surface.
// * *A toplevel surface is not fullscreen, maximized or transient.
//
//* *@ingroup iface_wl_shell_surface
// * *Map the surface relative to an existing surface.
// * *The x and y arguments specify the location of the upper left
// *corner of the surface relative to the upper left corner of the
// *parent surface, in surface-local coordinates.
// * *The flags argument controls details of the transient behaviour.
//
//* *@ingroup iface_wl_shell_surface
// * *Map the surface as a fullscreen surface.
// * *If an output parameter is given then the surface will be made
// *fullscreen on that output. If the client does not specify the
// *output then the compositor will apply its policy - usually
// *choosing the output on which the surface has the biggest surface
// *area.
// * *The client may specify a method to resolve a size conflict
// *between the output size and the surface size - this is provided
// *through the method parameter.
// * *The framerate parameter is used only when the method is set
// *to "driver", to indicate the preferred framerate. A value of 0
// *indicates that the client does not care about framerate.  The
// *framerate is specified in mHz, that is framerate of 60000 is 60Hz.
// * *A method of "scale" or "driver" implies a scaling operation of
// *the surface, either via a direct scaling operation or a change of
// *the output mode. This will override any kind of output scaling, so
// *that mapping a surface with a buffer size equal to the mode can
// *fill the screen independent of buffer_scale.
// * *A method of "fill" means we don't scale up the buffer, however
// *any output scale is applied. This means that you may run into
// *an edge case where the application maps a buffer with the same
// *size of the output mode but buffer_scale 1 (thus making a
// *surface larger than the output). In this case it is allowed to
// *downscale the results to fit the screen.
// * *The compositor must reply to this request with a configure event
// *with the dimensions for the output on which the surface will
// *be made fullscreen.
//
//* *@ingroup iface_wl_shell_surface
// * *Map the surface as a popup.
// * *A popup surface is a transient surface with an added pointer
// *grab.
// * *An existing implicit grab will be changed to owner-events mode,
// *and the popup grab will continue after the implicit grab ends
// *(i.e. releasing the mouse button does not cause the popup to
// *be unmapped).
// * *The popup grab continues until the window is destroyed or a
// *mouse button is pressed in any other client's window. A click
// *in any of the client's surfaces is reported as normal, however,
// *clicks in other clients' surfaces will be discarded and trigger
// *the callback.
// * *The x and y arguments specify the location of the upper left
// *corner of the surface relative to the upper left corner of the
// *parent surface, in surface-local coordinates.
//
//* *@ingroup iface_wl_shell_surface
// * *Map the surface as a maximized surface.
// * *If an output parameter is given then the surface will be
// *maximized on that output. If the client does not specify the
// *output then the compositor will apply its policy - usually
// *choosing the output on which the surface has the biggest surface
// *area.
// * *The compositor will reply with a configure event telling
// *the expected new surface size. The operation is completed
// *on the next buffer attach to this surface.
// * *A maximized surface typically fills the entire output it is
// *bound to, except for desktop elements such as panels. This is
// *the main difference between a maximized shell surface and a
// *fullscreen shell surface.
// * *The details depend on the compositor implementation.
//
//* *@ingroup iface_wl_shell_surface
// * *Set a short title for the surface.
// * *This string may be used to identify the surface in a task bar,
// *window list, or other user interface elements provided by the
// *compositor.
// * *The string must be encoded in UTF-8.
//
//* *@ingroup iface_wl_shell_surface
// * *Set a class for the surface.
// * *The surface class identifies the general class of applications
// *to which the surface belongs. A common convention is to use the
// *file name (or the full path if it is a non-standard location) of
// *the application's .desktop file as the class.
//
//* *@ingroup iface_C.wl_surface
// *C.wl_surface error values
// * *These errors can be emitted in response to C.wl_surface requests.
//
enum C.wl_surface_error {

//*	 *buffer scale value is invalid
//
	C.wl_surface_error_invalid_scale = 0
//*	 *buffer transform value is invalid
//
	C.wl_surface_error_invalid_transform = 1
//*	 *buffer size is invalid
//
	C.wl_surface_error_invalid_size = 2
//*	 *buffer offset is invalid
//
	C.wl_surface_error_invalid_offset = 3
//*	 *surface was destroyed before its role object
//
	C.wl_surface_error_defunct_role_object = 4
}

// C.wl_surface_ERROR_ENUM
//* *@ingroup iface_C.wl_surface
// *@struct C.wl_surface_listener
//
struct C.wl_surface_listener {
//*	 *surface enters an output
//	 *	 *This is emitted whenever a surface's creation, movement, or
//	 *resizing results in some part of it being within the scanout
//	 *region of an output.
//	 *	 *Note that a surface may be overlapping with zero or more
//	 *outputs.
//	 *@param output output entered by the surface
//
	enter fn (voidptr, &C.wl_surface, &Wl_output)
//*	 *surface leaves an output
//	 *	 *This is emitted whenever a surface's creation, movement, or
//	 *resizing results in it no longer having any part of it within
//	 *the scanout region of an output.
//	 *	 *Clients should not use the number of outputs the surface is on
//	 *for frame throttling purposes. The surface might be hidden even
//	 *if no leave event has been sent, and the compositor might expect
//	 *new surface content updates even if no enter event has been
//	 *sent. The frame event should be used instead.
//	 *@param output output left by the surface
//
	leave fn (voidptr, &C.wl_surface, &Wl_output)
//*	 *preferred buffer scale for the surface
//	 *	 *This event indicates the preferred buffer scale for this
//	 *surface. It is sent whenever the compositor's preference
//	 *changes.
//	 *	 *Before receiving this event the preferred buffer scale for this
//	 *surface is 1.
//	 *	 *It is intended that scaling aware clients use this event to
//	 *scale their content and use C.wl_surface.set_buffer_scale to
//	 *indicate the scale they have rendered with. This allows clients
//	 *to supply a higher detail buffer.
//	 *	 *The compositor shall emit a scale value greater than 0.
//	 *@param factor preferred scaling factor
//	 *@since 6
//
	preferred_buffer_scale fn (voidptr, &C.wl_surface, int)
//*	 *preferred buffer transform for the surface
//	 *	 *This event indicates the preferred buffer transform for this
//	 *surface. It is sent whenever the compositor's preference
//	 *changes.
//	 *	 *Before receiving this event the preferred buffer transform for
//	 *this surface is normal.
//	 *	 *Applying this transformation to the surface buffer contents and
//	 *using C.wl_surface.set_buffer_transform might allow the compositor
//	 *to use the surface buffer more efficiently.
//	 *@param transform preferred transform
//	 *@since 6
//
	preferred_buffer_transform fn (voidptr, &C.wl_surface, u32)
}
//* *@ingroup iface_C.wl_surface
//
//* *@ingroup iface_C.wl_surface
//
//* *@ingroup iface_C.wl_surface
//
//* *@ingroup iface_C.wl_surface
//
//* *@ingroup iface_C.wl_surface
//
//* *@ingroup iface_C.wl_surface
//
//* *@ingroup iface_C.wl_surface
//
//* *@ingroup iface_C.wl_surface
//
//* *@ingroup iface_C.wl_surface
//
//* *@ingroup iface_C.wl_surface
//
//* *@ingroup iface_C.wl_surface
//
//* *@ingroup iface_C.wl_surface
//
//* *@ingroup iface_C.wl_surface
//
//* *@ingroup iface_C.wl_surface
//
//* *@ingroup iface_C.wl_surface
//
//* *@ingroup iface_C.wl_surface
//
//*@ingroup iface_C.wl_surface
//*@ingroup iface_C.wl_surface
//* *@ingroup iface_C.wl_surface
// * *Deletes the surface and invalidates its object ID.
//
//* *@ingroup iface_C.wl_surface
// * *Set a buffer as the content of this surface.
// * *The new size of the surface is calculated based on the buffer
// *size transformed by the inverse buffer_transform and the
// *inverse buffer_scale. This means that at commit time the supplied
// *buffer size must be an integer multiple of the buffer_scale. If
// *that's not the case, an invalid_size error is sent.
// * *The x and y arguments specify the location of the new pending
// *buffer's upper left corner, relative to the current buffer's upper
// *left corner, in surface-local coordinates. In other words, the
// *x and y, combined with the new surface size define in which
// *directions the surface's size changes. Setting anything other than 0
// *as x and y arguments is discouraged, and should instead be replaced
// *with using the separate C.wl_surface.offset request.
// * *When the bound C.wl_surface version is 5 or higher, passing any
// *non-zero x or y is a protocol violation, and will result in an
// *'invalid_offset' error being raised. The x and y arguments are ignored
// *and do not change the pending state. To achieve equivalent semantics,
// *use C.wl_surface.offset.
// * *Surface contents are double-buffered state, see C.wl_surface.commit.
// * *The initial surface contents are void; there is no content.
// *C.wl_surface.attach assigns the given wl_buffer as the pending
// *wl_buffer. C.wl_surface.commit makes the pending wl_buffer the new
// *surface contents, and the size of the surface becomes the size
// *calculated from the wl_buffer, as described above. After commit,
// *there is no pending buffer until the next attach.
// * *Committing a pending wl_buffer allows the compositor to read the
// *pixels in the wl_buffer. The compositor may access the pixels at
// *any time after the C.wl_surface.commit request. When the compositor
// *will not access the pixels anymore, it will send the
// *wl_buffer.release event. Only after receiving wl_buffer.release,
// *the client may reuse the wl_buffer. A wl_buffer that has been
// *attached and then replaced by another attach instead of committed
// *will not receive a release event, and is not used by the
// *compositor.
// * *If a pending wl_buffer has been committed to more than one C.wl_surface,
// *the delivery of wl_buffer.release events becomes undefined. A well
// *behaved client should not rely on wl_buffer.release events in this
// *case. Alternatively, a client could create multiple wl_buffer objects
// *from the same backing storage or use a protocol extension providing
// *per-commit release notifications.
// * *Destroying the wl_buffer after wl_buffer.release does not change
// *the surface contents. Destroying the wl_buffer before wl_buffer.release
// *is allowed as long as the underlying buffer storage isn't re-used (this
// *can happen e.g. on client process termination). However, if the client
// *destroys the wl_buffer before receiving the wl_buffer.release event and
// *mutates the underlying buffer storage, the surface contents become
// *undefined immediately.
// * *If C.wl_surface.attach is sent with a NULL wl_buffer, the
// *following C.wl_surface.commit will remove the surface content.
// * *If a pending wl_buffer has been destroyed, the result is not specified.
// *Many compositors are known to remove the surface content on the following
// *C.wl_surface.commit, but this behaviour is not universal. Clients seeking to
// *maximise compatibility should not destroy pending buffers and should
// *ensure that they explicitly remove content from surfaces, even after
// *destroying buffers.
//
//* *@ingroup iface_C.wl_surface
// * *This request is used to describe the regions where the pending
// *buffer is different from the current surface contents, and where
// *the surface therefore needs to be repainted. The compositor
// *ignores the parts of the damage that fall outside of the surface.
// * *Damage is double-buffered state, see C.wl_surface.commit.
// * *The damage rectangle is specified in surface-local coordinates,
// *where x and y specify the upper left corner of the damage rectangle.
// * *The initial value for pending damage is empty: no damage.
// *C.wl_surface.damage adds pending damage: the new pending damage
// *is the union of old pending damage and the given rectangle.
// * *C.wl_surface.commit assigns pending damage as the current damage,
// *and clears pending damage. The server will clear the current
// *damage as it repaints the surface.
// * *Note! New clients should not use this request. Instead damage can be
// *posted with C.wl_surface.damage_buffer which uses buffer coordinates
// *instead of surface coordinates.
//
//* *@ingroup iface_C.wl_surface
// * *Request a notification when it is a good time to start drawing a new
// *frame, by creating a frame callback. This is useful for throttling
// *redrawing operations, and driving animations.
// * *When a client is animating on a C.wl_surface, it can use the 'frame'
// *request to get notified when it is a good time to draw and commit the
// *next frame of animation. If the client commits an update earlier than
// *that, it is likely that some updates will not make it to the display,
// *and the client is wasting resources by drawing too often.
// * *The frame request will take effect on the next C.wl_surface.commit.
// *The notification will only be posted for one frame unless
// *requested again. For a C.wl_surface, the notifications are posted in
// *the order the frame requests were committed.
// * *The server must send the notifications so that a client
// *will not send excessive updates, while still allowing
// *the highest possible update rate for clients that wait for the reply
// *before drawing again. The server should give some time for the client
// *to draw and commit after sending the frame callback events to let it
// *hit the next output refresh.
// * *A server should avoid signaling the frame callbacks if the
// *surface is not visible in any way, e.g. the surface is off-screen,
// *or completely obscured by other opaque surfaces.
// * *The object returned by this request will be destroyed by the
// *compositor after the callback is fired and as such the client must not
// *attempt to use it after that point.
// * *The callback_data passed in the callback is the current time, in
// *milliseconds, with an undefined base.
//
//* *@ingroup iface_C.wl_surface
// * *This request sets the region of the surface that contains
// *opaque content.
// * *The opaque region is an optimization hint for the compositor
// *that lets it optimize the redrawing of content behind opaque
// *regions.  Setting an opaque region is not required for correct
// *behaviour, but marking transparent content as opaque will result
// *in repaint artifacts.
// * *The opaque region is specified in surface-local coordinates.
// * *The compositor ignores the parts of the opaque region that fall
// *outside of the surface.
// * *Opaque region is double-buffered state, see C.wl_surface.commit.
// * *C.wl_surface.set_opaque_region changes the pending opaque region.
// *C.wl_surface.commit copies the pending region to the current region.
// *Otherwise, the pending and current regions are never changed.
// * *The initial value for an opaque region is empty. Setting the pending
// *opaque region has copy semantics, and the wl_region object can be
// *destroyed immediately. A NULL wl_region causes the pending opaque
// *region to be set to empty.
//
//* *@ingroup iface_C.wl_surface
// * *This request sets the region of the surface that can receive
// *pointer and touch events.
// * *Input events happening outside of this region will try the next
// *surface in the server surface stack. The compositor ignores the
// *parts of the input region that fall outside of the surface.
// * *The input region is specified in surface-local coordinates.
// * *Input region is double-buffered state, see C.wl_surface.commit.
// * *C.wl_surface.set_input_region changes the pending input region.
// *C.wl_surface.commit copies the pending region to the current region.
// *Otherwise the pending and current regions are never changed,
// *except cursor and icon surfaces are special cases, see
// *C.wl_pointer.set_cursor and wl_data_device.start_drag.
// * *The initial value for an input region is infinite. That means the
// *whole surface will accept input. Setting the pending input region
// *has copy semantics, and the wl_region object can be destroyed
// *immediately. A NULL wl_region causes the input region to be set
// *to infinite.
//
//* *@ingroup iface_C.wl_surface
// * *Surface state (input, opaque, and damage regions, attached buffers,
// *etc.) is double-buffered. Protocol requests modify the pending state,
// *as opposed to the active state in use by the compositor.
// * *A commit request atomically creates a content update from the pending
// *state, even if the pending state has not been touched. The content
// *update is placed in a queue until it becomes active. After commit, the
// *new pending state is as documented for each related request.
// * *When the content update is applied, the wl_buffer is applied before all
// *other state. This means that all coordinates in double-buffered state
// *are relative to the newly attached wl_buffers, except for
// *C.wl_surface.attach itself. If there is no newly attached wl_buffer, the
// *coordinates are relative to the previous content update.
// * *All requests that need a commit to become effective are documented
// *to affect double-buffered state.
// * *Other interfaces may add further double-buffered surface state.
//
//* *@ingroup iface_C.wl_surface
// * *This request sets the transformation that the client has already applied
// *to the content of the buffer. The accepted values for the transform
// *parameter are the values for wl_output.transform.
// * *The compositor applies the inverse of this transformation whenever it
// *uses the buffer contents.
// * *Buffer transform is double-buffered state, see C.wl_surface.commit.
// * *A newly created surface has its buffer transformation set to normal.
// * *C.wl_surface.set_buffer_transform changes the pending buffer
// *transformation. C.wl_surface.commit copies the pending buffer
// *transformation to the current one. Otherwise, the pending and current
// *values are never changed.
// * *The purpose of this request is to allow clients to render content
// *according to the output transform, thus permitting the compositor to
// *use certain optimizations even if the display is rotated. Using
// *hardware overlays and scanning out a client buffer for fullscreen
// *surfaces are examples of such optimizations. Those optimizations are
// *highly dependent on the compositor implementation, so the use of this
// *request should be considered on a case-by-case basis.
// * *Note that if the transform value includes 90 or 270 degree rotation,
// *the width of the buffer will become the surface height and the height
// *of the buffer will become the surface width.
// * *If transform is not one of the values from the
// *wl_output.transform enum the invalid_transform protocol error
// *is raised.
//
//* *@ingroup iface_C.wl_surface
// * *This request sets an optional scaling factor on how the compositor
// *interprets the contents of the buffer attached to the window.
// * *Buffer scale is double-buffered state, see C.wl_surface.commit.
// * *A newly created surface has its buffer scale set to 1.
// * *C.wl_surface.set_buffer_scale changes the pending buffer scale.
// *C.wl_surface.commit copies the pending buffer scale to the current one.
// *Otherwise, the pending and current values are never changed.
// * *The purpose of this request is to allow clients to supply higher
// *resolution buffer data for use on high resolution outputs. It is
// *intended that you pick the same buffer scale as the scale of the
// *output that the surface is displayed on. This means the compositor
// *can avoid scaling when rendering the surface on that output.
// * *Note that if the scale is larger than 1, then you have to attach
// *a buffer that is larger (by a factor of scale in each dimension)
// *than the desired surface size.
// * *If scale is not greater than 0 the invalid_scale protocol error is
// *raised.
//
//* *@ingroup iface_C.wl_surface
// * *This request is used to describe the regions where the pending
// *buffer is different from the current surface contents, and where
// *the surface therefore needs to be repainted. The compositor
// *ignores the parts of the damage that fall outside of the surface.
// * *Damage is double-buffered state, see C.wl_surface.commit.
// * *The damage rectangle is specified in buffer coordinates,
// *where x and y specify the upper left corner of the damage rectangle.
// * *The initial value for pending damage is empty: no damage.
// *C.wl_surface.damage_buffer adds pending damage: the new pending
// *damage is the union of old pending damage and the given rectangle.
// * *C.wl_surface.commit assigns pending damage as the current damage,
// *and clears pending damage. The server will clear the current
// *damage as it repaints the surface.
// * *This request differs from C.wl_surface.damage in only one way - it
// *takes damage in buffer coordinates instead of surface-local
// *coordinates. While this generally is more intuitive than surface
// *coordinates, it is especially desirable when using wp_viewport
// *or when a drawing library (like EGL) is unaware of buffer scale
// *and buffer transform.
// * *Note: Because buffer transformation changes and damage requests may
// *be interleaved in the protocol stream, it is impossible to determine
// *the actual mapping between surface and buffer damage until
// *C.wl_surface.commit time. Therefore, compositors wishing to take both
// *kinds of damage into account will have to accumulate damage from the
// *two requests separately and only transform from one to the other
// *after receiving the C.wl_surface.commit.
//
//* *@ingroup iface_C.wl_surface
// * *The x and y arguments specify the location of the new pending
// *buffer's upper left corner, relative to the current buffer's upper
// *left corner, in surface-local coordinates. In other words, the
// *x and y, combined with the new surface size define in which
// *directions the surface's size changes.
// * *The exact semantics of C.wl_surface.offset are role-specific. Refer to
// *the documentation of specific roles for more information.
// * *Surface location offset is double-buffered state, see
// *C.wl_surface.commit.
// * *This request is semantically equivalent to and the replaces the x and y
// *arguments in the C.wl_surface.attach request in wl_surface versions prior
// *to 5. See C.wl_surface.attach for details.
//
//* *@ingroup iface_wl_seat
// *seat capability bitmask
// * *This is a bitmask of capabilities this seat has; if a member is
// *set, then it is present on the seat.
//
pub enum Wl_seat_capability {

//*	 *the seat has pointer devices
//
	wl_seat_capability_pointer = 1
//*	 *the seat has one or more keyboards
//
	wl_seat_capability_keyboard = 2
//*	 *the seat has touch devices
//
	wl_seat_capability_touch = 4
}

// WL_SEAT_CAPABILITY_ENUM
//* *@ingroup iface_wl_seat
// *wl_seat error values
// * *These errors can be emitted in response to wl_seat requests.
//
pub enum Wl_seat_error {

//*	 *get_pointer, get_keyboard or get_touch called on seat without the matching capability
//
	wl_seat_error_missing_capability = 0
}

// WL_SEAT_ERROR_ENUM
//* *@ingroup iface_wl_seat
// *@struct wl_seat_listener
//
struct Wl_seat_listener {
//*	 *seat capabilities changed
//	 *	 *This is sent on binding to the seat global or whenever a seat
//	 *gains or loses the pointer, keyboard or touch capabilities. The
//	 *argument is a capability enum containing the complete set of
//	 *capabilities this seat has.
//	 *	 *When the pointer capability is added, a client may create a
//	 *C.wl_pointer object using the wl_seat.get_pointer request. This
//	 *object will receive pointer events until the capability is
//	 *removed in the future.
//	 *	 *When the pointer capability is removed, a client should destroy
//	 *the C.wl_pointer objects associated with the seat where the
//	 *capability was removed, using the C.wl_pointer.release request. No
//	 *further pointer events will be received on these objects.
//	 *	 *In some compositors, if a seat regains the pointer capability
//	 *and a client has a previously obtained C.wl_pointer object of
//	 *version 4 or less, that object may start sending pointer events
//	 *again. This behavior is considered a misinterpretation of the
//	 *intended behavior and must not be relied upon by the client.
//	 *C.wl_pointer objects of version 5 or later must not send events if
//	 *created before the most recent event notifying the client of an
//	 *added pointer capability.
//	 *	 *The above behavior also applies to wl_keyboard and wl_touch with
//	 *the keyboard and touch capabilities, respectively.
//	 *@param capabilities capabilities of the seat
//
	capabilities fn (voidptr, &Wl_seat, u32)
//*	 *unique identifier for this seat
//	 *	 *In a multi-seat configuration the seat name can be used by
//	 *clients to help identify which physical devices the seat
//	 *represents.
//	 *	 *The seat name is a UTF-8 string with no convention defined for
//	 *its contents. Each name is unique among all wl_seat globals. The
//	 *name is only guaranteed to be unique for the current compositor
//	 *instance.
//	 *	 *The same seat names are used for all clients. Thus, the name can
//	 *be shared across processes to refer to a specific wl_seat
//	 *global.
//	 *	 *The name event is sent after binding to the seat global, and
//	 *should be sent before announcing capabilities. This event only
//	 *sent once per seat object, and the name does not change over the
//	 *lifetime of the wl_seat global.
//	 *	 *Compositors may re-use the same seat name if the wl_seat global
//	 *is destroyed and re-created later.
//	 *@param name seat identifier
//	 *@since 2
//
	name fn (voidptr, &Wl_seat, &i8)
}
//* *@ingroup iface_wl_seat
//
//* *@ingroup iface_wl_seat
//
//* *@ingroup iface_wl_seat
//
//* *@ingroup iface_wl_seat
//
//* *@ingroup iface_wl_seat
//
//* *@ingroup iface_wl_seat
//
//* *@ingroup iface_wl_seat
//
//*@ingroup iface_wl_seat
//*@ingroup iface_wl_seat
//*@ingroup iface_wl_seat
//* *@ingroup iface_wl_seat
// * *The ID provided will be initialized to the C.wl_pointer interface
// *for this seat.
// * *This request only takes effect if the seat has the pointer
// *capability, or has had the pointer capability in the past.
// *It is a protocol violation to issue this request on a seat that has
// *never had the pointer capability. The missing_capability error will
// *be sent in this case.
//
//* *@ingroup iface_wl_seat
// * *The ID provided will be initialized to the wl_keyboard interface
// *for this seat.
// * *This request only takes effect if the seat has the keyboard
// *capability, or has had the keyboard capability in the past.
// *It is a protocol violation to issue this request on a seat that has
// *never had the keyboard capability. The missing_capability error will
// *be sent in this case.
//
//* *@ingroup iface_wl_seat
// * *The ID provided will be initialized to the wl_touch interface
// *for this seat.
// * *This request only takes effect if the seat has the touch
// *capability, or has had the touch capability in the past.
// *It is a protocol violation to issue this request on a seat that has
// *never had the touch capability. The missing_capability error will
// *be sent in this case.
//
//* *@ingroup iface_wl_seat
// * *Using this request a client can tell the server that it is not going to
// *use the seat object anymore.
//
enum C.wl_pointer_error {
//*	 *given C.wl_surface has another role
//
	C.wl_pointer_error_role = 0
}

// C.wl_pointer_ERROR_ENUM
//* *@ingroup iface_C.wl_pointer
// *physical button state
// * *Describes the physical state of a button that produced the button
// *event.
//
enum C.wl_pointer_button_state {

//*	 *the button is not pressed
//
	C.wl_pointer_button_state_released = 0
//*	 *the button is pressed
//
	C.wl_pointer_button_state_pressed = 1
}

// C.wl_pointer_BUTTON_STATE_ENUM
//* *@ingroup iface_C.wl_pointer
// *axis types
// * *Describes the axis types of scroll events.
//
enum C.wl_pointer_axis {

//*	 *vertical axis
//
	C.wl_pointer_axis_vertical_scroll = 0
//*	 *horizontal axis
//
	C.wl_pointer_axis_horizontal_scroll = 1
}

// C.wl_pointer_AXIS_ENUM
//* *@ingroup iface_C.wl_pointer
// *axis source types
// * *Describes the source types for axis events. This indicates to the
// *client how an axis event was physically generated; a client may
// *adjust the user interface accordingly. For example, scroll events
// *from a "finger" source may be in a smooth coordinate space with
// *kinetic scrolling whereas a "wheel" source may be in discrete steps
// *of a number of lines.
// * *The "continuous" axis source is a device generating events in a
// *continuous coordinate space, but using something other than a
// *finger. One example for this source is button-based scrolling where
// *the vertical motion of a device is converted to scroll events while
// *a button is held down.
// * *The "wheel tilt" axis source indicates that the actual device is a
// *wheel but the scroll event is not caused by a rotation but a
// *(usually sideways) tilt of the wheel.
//
enum C.wl_pointer_axis_source {

//*	 *a physical wheel rotation
//
	C.wl_pointer_axis_source_wheel = 0
//*	 *finger on a touch surface
//
	C.wl_pointer_axis_source_finger = 1
//*	 *continuous coordinate space
//
	C.wl_pointer_axis_source_continuous = 2
//*	 *a physical wheel tilt
//	 *@since 6
//
	C.wl_pointer_axis_source_wheel_tilt = 3
}

//* *@ingroup iface_C.wl_pointer
//
// C.wl_pointer_AXIS_SOURCE_ENUM
//* *@ingroup iface_C.wl_pointer
// *axis relative direction
// * *This specifies the direction of the physical motion that caused a
// *C.wl_pointer.axis event, relative to the wl_pointer.axis direction.
//
enum C.wl_pointer_axis_relative_direction {

//*	 *physical motion matches axis direction
//
	C.wl_pointer_axis_relative_direction_identical = 0
//*	 *physical motion is the inverse of the axis direction
//
	C.wl_pointer_axis_relative_direction_inverted = 1
}

// C.wl_pointer_AXIS_RELATIVE_DIRECTION_ENUM
//* *@ingroup iface_C.wl_pointer
// *@struct C.wl_pointer_listener
//
struct C.wl_pointer_listener {
//*	 *enter event
//	 *	 *Notification that this seat's pointer is focused on a certain
//	 *surface.
//	 *	 *When a seat's focus enters a surface, the pointer image is
//	 *undefined and a client should respond to this event by setting
//	 *an appropriate pointer image with the set_cursor request.
//	 *@param serial serial number of the enter event
//	 *@param surface surface entered by the pointer
//	 *@param surface_x surface-local x coordinate
//	 *@param surface_y surface-local y coordinate
//
	enter fn (voidptr, &C.wl_pointer, u32, &C.wl_surface, Wl_int, Wl_int)
//*	 *leave event
//	 *	 *Notification that this seat's pointer is no longer focused on
//	 *a certain surface.
//	 *	 *The leave notification is sent before the enter notification for
//	 *the new focus.
//	 *@param serial serial number of the leave event
//	 *@param surface surface left by the pointer
//
	leave fn (voidptr, &C.wl_pointer, u32, &C.wl_surface)
//*	 *pointer motion event
//	 *	 *Notification of pointer location change. The arguments
//	 *surface_x and surface_y are the location relative to the focused
//	 *surface.
//	 *@param time timestamp with millisecond granularity
//	 *@param surface_x surface-local x coordinate
//	 *@param surface_y surface-local y coordinate
//
	motion fn (voidptr, &C.wl_pointer, u32, Wl_int, Wl_int)
//*	 *pointer button event
//	 *	 *Mouse button click and release notifications.
//	 *	 *The location of the click is given by the last motion or enter
//	 *event. The time argument is a timestamp with millisecond
//	 *granularity, with an undefined base.
//	 *	 *The button is a button code as defined in the Linux kernel's
//	 *linux/input-event-codes.h header file, e.g. BTN_LEFT.
//	 *	 *Any 16-bit button code value is reserved for future additions to
//	 *the kernel's event code list. All other button codes above
//	 *0xFFFF are currently undefined but may be used in future
//	 *versions of this protocol.
//	 *@param serial serial number of the button event
//	 *@param time timestamp with millisecond granularity
//	 *@param button button that produced the event
//	 *@param state physical state of the button
//
	button fn (voidptr, &C.wl_pointer, u32, u32, u32, u32)
//*	 *axis event
//	 *	 *Scroll and other axis notifications.
//	 *	 *For scroll events (vertical and horizontal scroll axes), the
//	 *value parameter is the length of a vector along the specified
//	 *axis in a coordinate space identical to those of motion events,
//	 *representing a relative movement along the specified axis.
//	 *	 *For devices that support movements non-parallel to axes multiple
//	 *axis events will be emitted.
//	 *	 *When applicable, for example for touch pads, the server can
//	 *choose to emit scroll events where the motion vector is
//	 *equivalent to a motion event vector.
//	 *	 *When applicable, a client can transform its content relative to
//	 *the scroll distance.
//	 *@param time timestamp with millisecond granularity
//	 *@param axis axis type
//	 *@param value length of vector in surface-local coordinate space
//
	axis fn (voidptr, &C.wl_pointer, u32, u32, Wl_int)
//*	 *end of a pointer event sequence
//	 *	 *Indicates the end of a set of events that logically belong
//	 *together. A client is expected to accumulate the data in all
//	 *events within the frame before proceeding.
//	 *	 *All C.wl_pointer events before a wl_pointer.frame event belong
//	 *logically together. For example, in a diagonal scroll motion the
//	 *compositor will send an optional C.wl_pointer.axis_source event,
//	 *two C.wl_pointer.axis events (horizontal and vertical) and finally
//	 *a C.wl_pointer.frame event. The client may use this information to
//	 *calculate a diagonal vector for scrolling.
//	 *	 *When multiple C.wl_pointer.axis events occur within the same
//	 *frame, the motion vector is the combined motion of all events.
//	 *When a C.wl_pointer.axis and a wl_pointer.axis_stop event occur
//	 *within the same frame, this indicates that axis movement in one
//	 *axis has stopped but continues in the other axis. When multiple
//	 *C.wl_pointer.axis_stop events occur within the same frame, this
//	 *indicates that these axes stopped in the same instance.
//	 *	 *A C.wl_pointer.frame event is sent for every logical event group,
//	 *even if the group only contains a single C.wl_pointer event.
//	 *Specifically, a client may get a sequence: motion, frame,
//	 *button, frame, axis, frame, axis_stop, frame.
//	 *	 *The C.wl_pointer.enter and wl_pointer.leave events are logical
//	 *events generated by the compositor and not the hardware. These
//	 *events are also grouped by a C.wl_pointer.frame. When a pointer
//	 *moves from one surface to another, a compositor should group the
//	 *C.wl_pointer.leave event within the same wl_pointer.frame.
//	 *However, a client must not rely on C.wl_pointer.leave and
//	 *C.wl_pointer.enter being in the same wl_pointer.frame.
//	 *Compositor-specific policies may require the C.wl_pointer.leave
//	 *and C.wl_pointer.enter event being split across multiple
//	 *C.wl_pointer.frame groups.
//	 *@since 5
//
	frame fn (voidptr, &C.wl_pointer)
//*	 *axis source event
//	 *	 *Source information for scroll and other axes.
//	 *	 *This event does not occur on its own. It is sent before a
//	 *C.wl_pointer.frame event and carries the source information for
//	 *all events within that frame.
//	 *	 *The source specifies how this event was generated. If the source
//	 *is C.wl_pointer.axis_source.finger, a wl_pointer.axis_stop event
//	 *will be sent when the user lifts the finger off the device.
//	 *	 *If the source is C.wl_pointer.axis_source.wheel,
//	 *C.wl_pointer.axis_source.wheel_tilt or
//	 *C.wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event
//	 *may or may not be sent. Whether a compositor sends an axis_stop
//	 *event for these sources is hardware-specific and
//	 *implementation-dependent; clients must not rely on receiving an
//	 *axis_stop event for these scroll sources and should treat scroll
//	 *sequences from these scroll sources as unterminated by default.
//	 *	 *This event is optional. If the source is unknown for a
//	 *particular axis event sequence, no event is sent. Only one
//	 *C.wl_pointer.axis_source event is permitted per frame.
//	 *	 *The order of C.wl_pointer.axis_discrete and wl_pointer.axis_source
//	 *is not guaranteed.
//	 *@param axis_source source of the axis event
//	 *@since 5
//
	axis_source fn (voidptr, &C.wl_pointer, u32)
//*	 *axis stop event
//	 *	 *Stop notification for scroll and other axes.
//	 *	 *For some C.wl_pointer.axis_source types, a wl_pointer.axis_stop
//	 *event is sent to notify a client that the axis sequence has
//	 *terminated. This enables the client to implement kinetic
//	 *scrolling. See the C.wl_pointer.axis_source documentation for
//	 *information on when this event may be generated.
//	 *	 *Any C.wl_pointer.axis events with the same axis_source after this
//	 *event should be considered as the start of a new axis motion.
//	 *	 *The timestamp is to be interpreted identical to the timestamp in
//	 *the C.wl_pointer.axis event. The timestamp value may be the same
//	 *as a preceding C.wl_pointer.axis event.
//	 *@param time timestamp with millisecond granularity
//	 *@param axis the axis stopped with this event
//	 *@since 5
//
	axis_stop fn (voidptr, &C.wl_pointer, u32, u32)
//*	 *axis click event
//	 *	 *Discrete step information for scroll and other axes.
//	 *	 *This event carries the axis value of the C.wl_pointer.axis event
//	 *in discrete steps (e.g. mouse wheel clicks).
//	 *	 *This event is deprecated with C.wl_pointer version 8 - this event
//	 *is not sent to clients supporting version 8 or later.
//	 *	 *This event does not occur on its own, it is coupled with a
//	 *C.wl_pointer.axis event that represents this axis value on a
//	 *continuous scale. The protocol guarantees that each
//	 *axis_discrete event is always followed by exactly one axis event
//	 *with the same axis number within the same C.wl_pointer.frame. Note
//	 *that the protocol allows for other events to occur between the
//	 *axis_discrete and its coupled axis event, including other
//	 *axis_discrete or axis events. A C.wl_pointer.frame must not
//	 *contain more than one axis_discrete event per axis type.
//	 *	 *This event is optional; continuous scrolling devices like
//	 *two-finger scrolling on touchpads do not have discrete steps and
//	 *do not generate this event.
//	 *	 *The discrete value carries the directional information. e.g. a
//	 *value of -2 is two steps towards the negative direction of this
//	 *axis.
//	 *	 *The axis number is identical to the axis number in the
//	 *associated axis event.
//	 *	 *The order of C.wl_pointer.axis_discrete and wl_pointer.axis_source
//	 *is not guaranteed.
//	 *@param axis axis type
//	 *@param discrete number of steps
//	 *@since 5
//	 *@deprecated Deprecated since version 8
//
	axis_discrete fn (voidptr, &C.wl_pointer, u32, int)
//*	 *axis high-resolution scroll event
//	 *	 *Discrete high-resolution scroll information.
//	 *	 *This event carries high-resolution wheel scroll information,
//	 *with each multiple of 120 representing one logical scroll step
//	 *(a wheel detent). For example, an axis_value120 of 30 is one
//	 *quarter of a logical scroll step in the positive direction, a
//	 *value120 of -240 are two logical scroll steps in the negative
//	 *direction within the same hardware event. Clients that rely on
//	 *discrete scrolling should accumulate the value120 to multiples
//	 *of 120 before processing the event.
//	 *	 *The value120 must not be zero.
//	 *	 *This event replaces the C.wl_pointer.axis_discrete event in
//	 *clients supporting C.wl_pointer version 8 or later.
//	 *	 *Where a C.wl_pointer.axis_source event occurs in the same
//	 *C.wl_pointer.frame, the axis source applies to this event.
//	 *	 *The order of C.wl_pointer.axis_value120 and wl_pointer.axis_source
//	 *is not guaranteed.
//	 *@param axis axis type
//	 *@param value120 scroll distance as fraction of 120
//	 *@since 8
//
	axis_value120 fn (voidptr, &C.wl_pointer, u32, int)
//*	 *axis relative physical direction event
//	 *	 *Relative directional information of the entity causing the
//	 *axis motion.
//	 *	 *For a C.wl_pointer.axis event, the
//	 *C.wl_pointer.axis_relative_direction event specifies the movement
//	 *direction of the entity causing the C.wl_pointer.axis event. For
//	 *example: - if a user's fingers on a touchpad move down and this
//	 *causes a C.wl_pointer.axis vertical_scroll down event, the
//	 *physical direction is 'identical' - if a user's fingers on a
//	 *touchpad move down and this causes a C.wl_pointer.axis
//	 *vertical_scroll up scroll up event ('natural scrolling'), the
//	 *physical direction is 'inverted'.
//	 *	 *A client may use this information to adjust scroll motion of
//	 *components. Specifically, enabling natural scrolling causes the
//	 *content to change direction compared to traditional scrolling.
//	 *Some widgets like volume control sliders should usually match
//	 *the physical direction regardless of whether natural scrolling
//	 *is active. This event enables clients to match the scroll
//	 *direction of a widget to the physical direction.
//	 *	 *This event does not occur on its own, it is coupled with a
//	 *C.wl_pointer.axis event that represents this axis value. The
//	 *protocol guarantees that each axis_relative_direction event is
//	 *always followed by exactly one axis event with the same axis
//	 *number within the same C.wl_pointer.frame. Note that the protocol
//	 *allows for other events to occur between the
//	 *axis_relative_direction and its coupled axis event.
//	 *	 *The axis number is identical to the axis number in the
//	 *associated axis event.
//	 *	 *The order of C.wl_pointer.axis_relative_direction,
//	 *C.wl_pointer.axis_discrete and wl_pointer.axis_source is not
//	 *guaranteed.
//	 *@param axis axis type
//	 *@param direction physical direction relative to axis motion
//	 *@since 9
//
	axis_relative_direction fn (voidptr, &C.wl_pointer, u32, u32)
}
//* *@ingroup iface_C.wl_pointer
//
//* *@ingroup iface_C.wl_pointer
//
//* *@ingroup iface_C.wl_pointer
//
//* *@ingroup iface_C.wl_pointer
//
//* *@ingroup iface_C.wl_pointer
//
//* *@ingroup iface_C.wl_pointer
//
//* *@ingroup iface_C.wl_pointer
//
//* *@ingroup iface_C.wl_pointer
//
//* *@ingroup iface_C.wl_pointer
//
//* *@ingroup iface_C.wl_pointer
//
//* *@ingroup iface_C.wl_pointer
//
//* *@ingroup iface_C.wl_pointer
//
//* *@ingroup iface_C.wl_pointer
//
//* *@ingroup iface_C.wl_pointer
//
//*@ingroup iface_C.wl_pointer
//*@ingroup iface_C.wl_pointer
//*@ingroup iface_C.wl_pointer
//* *@ingroup iface_C.wl_pointer
// * *Set the pointer surface, i.e., the surface that contains the
// *pointer image (cursor). This request gives the surface the role
// *of a cursor. If the surface already has another role, it raises
// *a protocol error.
// * *The cursor actually changes only if the pointer
// *focus for this device is one of the requesting client's surfaces
// *or the surface parameter is the current pointer surface. If
// *there was a previous surface set with this request it is
// *replaced. If surface is NULL, the pointer image is hidden.
// * *The parameters hotspot_x and hotspot_y define the position of
// *the pointer surface relative to the pointer location. Its
// *top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
// *where (x, y) are the coordinates of the pointer location, in
// *surface-local coordinates.
// * *On C.wl_surface.offset requests to the pointer surface, hotspot_x
// *and hotspot_y are decremented by the x and y parameters
// *passed to the request. The offset must be applied by
// *C.wl_surface.commit as usual.
// * *The hotspot can also be updated by passing the currently set
// *pointer surface to this request with new values for hotspot_x
// *and hotspot_y.
// * *The input region is ignored for C.wl_surfaces with the role of
// *a cursor. When the use as a cursor ends, the C.wl_surface is
// *unmapped.
// * *The serial parameter must match the latest C.wl_pointer.enter
// *serial number sent to the client. Otherwise the request will be
// *ignored.
//
//* *@ingroup iface_C.wl_pointer
// * *Using this request a client can tell the server that it is not going to
// *use the pointer object anymore.
// * *This request destroys the pointer proxy object, so clients must not call
// *C.wl_pointer_destroy() after using this request.
//
//* *@ingroup iface_wl_keyboard
// *keyboard mapping format
// * *This specifies the format of the keymap provided to the
// *client with the wl_keyboard.keymap event.
//
pub enum Wl_keyboard_keymap_format {

//*	 *no keymap; client must understand how to interpret the raw keycode
//
	wl_keyboard_keymap_format_no_keymap = 0
//*	 *libxkbcommon compatible, null-terminated string; to determine the xkb keycode, clients must add 8 to the key event keycode
//
	wl_keyboard_keymap_format_xkb_v1 = 1
}

// WL_KEYBOARD_KEYMAP_FORMAT_ENUM
//* *@ingroup iface_wl_keyboard
// *physical key state
// * *Describes the physical state of a key that produced the key event.
// * *Since version 10, the key can be in a "repeated" pseudo-state which
// *means the same as "pressed", but is used to signal repetition in the
// *key event.
// * *The key may only enter the repeated state after entering the pressed
// *state and before entering the released state. This event may be
// *generated multiple times while the key is down.
//
pub enum Wl_keyboard_key_state {

//*	 *key is not pressed
//
	wl_keyboard_key_state_released = 0
//*	 *key is pressed
//
	wl_keyboard_key_state_pressed = 1
//*	 *key was repeated
//	 *@since 10
//
	wl_keyboard_key_state_repeated = 2
}

//* *@ingroup iface_wl_keyboard
//
// WL_KEYBOARD_KEY_STATE_ENUM
//* *@ingroup iface_wl_keyboard
// *@struct wl_keyboard_listener
//
struct Wl_keyboard_listener {
//*	 *keyboard mapping
//	 *	 *This event provides a file descriptor to the client which can
//	 *be memory-mapped in read-only mode to provide a keyboard mapping
//	 *description.
//	 *	 *From version 7 onwards, the fd must be mapped with MAP_PRIVATE
//	 *by the recipient, as MAP_SHARED may fail.
//	 *@param format keymap format
//	 *@param fd keymap file descriptor
//	 *@param size keymap size, in bytes
//
	keymap fn (voidptr, &Wl_keyboard, u32, int, u32)
//*	 *enter event
//	 *	 *Notification that this seat's keyboard focus is on a certain
//	 *surface.
//	 *	 *The compositor must send the wl_keyboard.modifiers event after
//	 *this event.
//	 *	 *In the wl_keyboard logical state, this event sets the active
//	 *surface to the surface argument and the keys currently logically
//	 *down to the keys in the keys argument. The compositor must not
//	 *send this event if the wl_keyboard already had an active surface
//	 *immediately before this event.
//	 *	 *Clients should not use the list of pressed keys to emulate
//	 *key-press events. The order of keys in the list is unspecified.
//	 *@param serial serial number of the enter event
//	 *@param surface surface gaining keyboard focus
//	 *@param keys the keys currently logically down
//
	enter fn (voidptr, &Wl_keyboard, u32, &C.wl_surface, &Wl_array)
//*	 *leave event
//	 *	 *Notification that this seat's keyboard focus is no longer on a
//	 *certain surface.
//	 *	 *The leave notification is sent before the enter notification for
//	 *the new focus.
//	 *	 *In the wl_keyboard logical state, this event resets all values
//	 *to their defaults. The compositor must not send this event if
//	 *the active surface of the wl_keyboard was not equal to the
//	 *surface argument immediately before this event.
//	 *@param serial serial number of the leave event
//	 *@param surface surface that lost keyboard focus
//
	leave fn (voidptr, &Wl_keyboard, u32, &C.wl_surface)
//*	 *key event
//	 *	 *A key was pressed or released. The time argument is a
//	 *timestamp with millisecond granularity, with an undefined base.
//	 *	 *The key is a platform-specific key code that can be interpreted
//	 *by feeding it to the keyboard mapping (see the keymap event).
//	 *	 *If this event produces a change in modifiers, then the resulting
//	 *wl_keyboard.modifiers event must be sent after this event.
//	 *	 *In the wl_keyboard logical state, this event adds the key to the
//	 *keys currently logically down (if the state argument is pressed)
//	 *or removes the key from the keys currently logically down (if
//	 *the state argument is released). The compositor must not send
//	 *this event if the wl_keyboard did not have an active surface
//	 *immediately before this event. The compositor must not send this
//	 *event if state is pressed (resp. released) and the key was
//	 *already logically down (resp. was not logically down)
//	 *immediately before this event.
//	 *	 *Since version 10, compositors may send key events with the
//	 *"repeated" key state when a wl_keyboard.repeat_info event with a
//	 *rate argument of 0 has been received. This allows the compositor
//	 *to take over the responsibility of key repetition.
//	 *@param serial serial number of the key event
//	 *@param time timestamp with millisecond granularity
//	 *@param key key that produced the event
//	 *@param state physical state of the key
//
	key fn (voidptr, &Wl_keyboard, u32, u32, u32, u32)
//*	 *modifier and group state
//	 *	 *Notifies clients that the modifier and/or group state has
//	 *changed, and it should update its local state.
//	 *	 *The compositor may send this event without a surface of the
//	 *client having keyboard focus, for example to tie modifier
//	 *information to pointer focus instead. If a modifier event with
//	 *pressed modifiers is sent without a prior enter event, the
//	 *client can assume the modifier state is valid until it receives
//	 *the next wl_keyboard.modifiers event. In order to reset the
//	 *modifier state again, the compositor can send a
//	 *wl_keyboard.modifiers event with no pressed modifiers.
//	 *	 *In the wl_keyboard logical state, this event updates the
//	 *modifiers and group.
//	 *@param serial serial number of the modifiers event
//	 *@param mods_depressed depressed modifiers
//	 *@param mods_latched latched modifiers
//	 *@param mods_locked locked modifiers
//	 *@param group keyboard layout
//
	modifiers fn (voidptr, &Wl_keyboard, u32, u32, u32, u32, u32)
//*	 *repeat rate and delay
//	 *	 *Informs the client about the keyboard's repeat rate and delay.
//	 *	 *This event is sent as soon as the wl_keyboard object has been
//	 *created, and is guaranteed to be received by the client before
//	 *any key press event.
//	 *	 *Negative values for either rate or delay are illegal. A rate of
//	 *zero will disable any repeating (regardless of the value of
//	 *delay).
//	 *	 *This event can be sent later on as well with a new value if
//	 *necessary, so clients should continue listening for the event
//	 *past the creation of wl_keyboard.
//	 *@param rate the rate of repeating keys in characters per second
//	 *@param delay delay in milliseconds since key down until repeating starts
//	 *@since 4
//
	repeat_info fn (voidptr, &Wl_keyboard, int, int)
}
//* *@ingroup iface_wl_keyboard
//
//* *@ingroup iface_wl_keyboard
//
//* *@ingroup iface_wl_keyboard
//
//* *@ingroup iface_wl_keyboard
//
//* *@ingroup iface_wl_keyboard
//
//* *@ingroup iface_wl_keyboard
//
//* *@ingroup iface_wl_keyboard
//
//* *@ingroup iface_wl_keyboard
//
//*@ingroup iface_wl_keyboard
//*@ingroup iface_wl_keyboard
//*@ingroup iface_wl_keyboard
//* *@ingroup iface_wl_keyboard
//
//* *@ingroup iface_wl_touch
// *@struct wl_touch_listener
//
struct Wl_touch_listener {
//*	 *touch down event and beginning of a touch sequence
//	 *	 *A new touch point has appeared on the surface. This touch
//	 *point is assigned a unique ID. Future events from this touch
//	 *point reference this ID. The ID ceases to be valid after a touch
//	 *up event and may be reused in the future.
//	 *@param serial serial number of the touch down event
//	 *@param time timestamp with millisecond granularity
//	 *@param surface surface touched
//	 *@param id the unique ID of this touch point
//	 *@param x surface-local x coordinate
//	 *@param y surface-local y coordinate
//
	down fn (voidptr, &Wl_touch, u32, u32, &C.wl_surface, int, Wl_int, Wl_int)
//*	 *end of a touch event sequence
//	 *	 *The touch point has disappeared. No further events will be
//	 *sent for this touch point and the touch point's ID is released
//	 *and may be reused in a future touch down event.
//	 *@param serial serial number of the touch up event
//	 *@param time timestamp with millisecond granularity
//	 *@param id the unique ID of this touch point
//
	up fn (voidptr, &Wl_touch, u32, u32, int)
//*	 *update of touch point coordinates
//	 *	 *A touch point has changed coordinates.
//	 *@param time timestamp with millisecond granularity
//	 *@param id the unique ID of this touch point
//	 *@param x surface-local x coordinate
//	 *@param y surface-local y coordinate
//
	motion fn (voidptr, &Wl_touch, u32, int, Wl_int, Wl_int)
//*	 *end of touch frame event
//	 *	 *Indicates the end of a set of events that logically belong
//	 *together. A client is expected to accumulate the data in all
//	 *events within the frame before proceeding.
//	 *	 *A wl_touch.frame terminates at least one event but otherwise no
//	 *guarantee is provided about the set of events within a frame. A
//	 *client must assume that any state not updated in a frame is
//	 *unchanged from the previously known state.
//
	frame fn (voidptr, &Wl_touch)
//*	 *touch session cancelled
//	 *	 *Sent if the compositor decides the touch stream is a global
//	 *gesture. No further events are sent to the clients from that
//	 *particular gesture. Touch cancellation applies to all touch
//	 *points currently active on this client's surface. The client is
//	 *responsible for finalizing the touch points, future touch points
//	 *on this surface may reuse the touch point ID.
//	 *	 *No frame event is required after the cancel event.
//
	cancel fn (voidptr, &Wl_touch)
//*	 *update shape of touch point
//	 *	 *Sent when a touchpoint has changed its shape.
//	 *	 *This event does not occur on its own. It is sent before a
//	 *wl_touch.frame event and carries the new shape information for
//	 *any previously reported, or new touch points of that frame.
//	 *	 *Other events describing the touch point such as wl_touch.down,
//	 *wl_touch.motion or wl_touch.orientation may be sent within the
//	 *same wl_touch.frame. A client should treat these events as a
//	 *single logical touch point update. The order of wl_touch.shape,
//	 *wl_touch.orientation and wl_touch.motion is not guaranteed. A
//	 *wl_touch.down event is guaranteed to occur before the first
//	 *wl_touch.shape event for this touch ID but both events may occur
//	 *within the same wl_touch.frame.
//	 *	 *A touchpoint shape is approximated by an ellipse through the
//	 *major and minor axis length. The major axis length describes the
//	 *longer diameter of the ellipse, while the minor axis length
//	 *describes the shorter diameter. Major and minor are orthogonal
//	 *and both are specified in surface-local coordinates. The center
//	 *of the ellipse is always at the touchpoint location as reported
//	 *by wl_touch.down or wl_touch.move.
//	 *	 *This event is only sent by the compositor if the touch device
//	 *supports shape reports. The client has to make reasonable
//	 *assumptions about the shape if it did not receive this event.
//	 *@param id the unique ID of this touch point
//	 *@param major length of the major axis in surface-local coordinates
//	 *@param minor length of the minor axis in surface-local coordinates
//	 *@since 6
//
	shape fn (voidptr, &Wl_touch, int, Wl_int, Wl_int)
//*	 *update orientation of touch point
//	 *	 *Sent when a touchpoint has changed its orientation.
//	 *	 *This event does not occur on its own. It is sent before a
//	 *wl_touch.frame event and carries the new shape information for
//	 *any previously reported, or new touch points of that frame.
//	 *	 *Other events describing the touch point such as wl_touch.down,
//	 *wl_touch.motion or wl_touch.shape may be sent within the same
//	 *wl_touch.frame. A client should treat these events as a single
//	 *logical touch point update. The order of wl_touch.shape,
//	 *wl_touch.orientation and wl_touch.motion is not guaranteed. A
//	 *wl_touch.down event is guaranteed to occur before the first
//	 *wl_touch.orientation event for this touch ID but both events may
//	 *occur within the same wl_touch.frame.
//	 *	 *The orientation describes the clockwise angle of a touchpoint's
//	 *major axis to the positive surface y-axis and is normalized to
//	 *the -180 to +180 degree range. The granularity of orientation
//	 *depends on the touch device, some devices only support binary
//	 *rotation values between 0 and 90 degrees.
//	 *	 *This event is only sent by the compositor if the touch device
//	 *supports orientation reports.
//	 *@param id the unique ID of this touch point
//	 *@param orientation angle between major axis and positive surface y-axis in degrees
//	 *@since 6
//
	orientation fn (voidptr, &Wl_touch, int, Wl_int)
}
//* *@ingroup iface_wl_touch
//
//* *@ingroup iface_wl_touch
//
//* *@ingroup iface_wl_touch
//
//* *@ingroup iface_wl_touch
//
//* *@ingroup iface_wl_touch
//
//* *@ingroup iface_wl_touch
//
//* *@ingroup iface_wl_touch
//
//* *@ingroup iface_wl_touch
//
//* *@ingroup iface_wl_touch
//
//*@ingroup iface_wl_touch
//*@ingroup iface_wl_touch
//*@ingroup iface_wl_touch
//* *@ingroup iface_wl_touch
//
//* *@ingroup iface_wl_output
// *subpixel geometry information
// * *This enumeration describes how the physical
// *pixels on an output are laid out.
//
pub enum Wl_output_subpixel {

//*	 *unknown geometry
//
	wl_output_subpixel_unknown = 0
//*	 *no geometry
//
	wl_output_subpixel_none = 1
//*	 *horizontal RGB
//
	wl_output_subpixel_horizontal_rgb = 2
//*	 *horizontal BGR
//
	wl_output_subpixel_horizontal_bgr = 3
//*	 *vertical RGB
//
	wl_output_subpixel_vertical_rgb = 4
//*	 *vertical BGR
//
	wl_output_subpixel_vertical_bgr = 5
}

// WL_OUTPUT_SUBPIXEL_ENUM
//* *@ingroup iface_wl_output
// *transformation applied to buffer contents
// * *This describes transformations that clients and compositors apply to
// *buffer contents.
// * *The flipped values correspond to an initial flip around a
// *vertical axis followed by rotation.
// * *The purpose is mainly to allow clients to render accordingly and
// *tell the compositor, so that for fullscreen surfaces, the
// *compositor will still be able to scan out directly from client
// *surfaces.
//
pub enum Wl_output_transform {

//*	 *no transform
//
	wl_output_transform_normal = 0
//*	 *90 degrees counter-clockwise
//
	wl_output_transform_90 = 1
//*	 *180 degrees counter-clockwise
//
	wl_output_transform_180 = 2
//*	 *270 degrees counter-clockwise
//
	wl_output_transform_270 = 3
//*	 *180 degree flip around a vertical axis
//
	wl_output_transform_flipped = 4
//*	 *flip and rotate 90 degrees counter-clockwise
//
	wl_output_transform_flipped_90 = 5
//*	 *flip and rotate 180 degrees counter-clockwise
//
	wl_output_transform_flipped_180 = 6
//*	 *flip and rotate 270 degrees counter-clockwise
//
	wl_output_transform_flipped_270 = 7
}

// WL_OUTPUT_TRANSFORM_ENUM
//* *@ingroup iface_wl_output
// *mode information
// * *These flags describe properties of an output mode.
// *They are used in the flags bitfield of the mode event.
//
pub enum Wl_output_mode {

//*	 *indicates this is the current mode
//
	wl_output_mode_current = 1
//*	 *indicates this is the preferred mode
//
	wl_output_mode_preferred = 2
}

// WL_OUTPUT_MODE_ENUM
//* *@ingroup iface_wl_output
// *@struct wl_output_listener
//
struct Wl_output_listener {
//*	 *properties of the output
//	 *	 *The geometry event describes geometric properties of the
//	 *output. The event is sent when binding to the output object and
//	 *whenever any of the properties change.
//	 *	 *The physical size can be set to zero if it doesn't make sense
//	 *for this output (e.g. for projectors or virtual outputs).
//	 *	 *The geometry event will be followed by a done event (starting
//	 *from version 2).
//	 *	 *Clients should use C.wl_surface.preferred_buffer_transform instead
//	 *of the transform advertised by this event to find the preferred
//	 *buffer transform to use for a surface.
//	 *	 *Note: wl_output only advertises partial information about the
//	 *output position and identification. Some compositors, for
//	 *instance those not implementing a desktop-style output layout or
//	 *those exposing virtual outputs, might fake this information.
//	 *Instead of using x and y, clients should use
//	 *xdg_output.logical_position. Instead of using make and model,
//	 *clients should use name and description.
//	 *@param x x position within the global compositor space
//	 *@param y y position within the global compositor space
//	 *@param physical_width width in millimeters of the output
//	 *@param physical_height height in millimeters of the output
//	 *@param subpixel subpixel orientation of the output
//	 *@param make textual description of the manufacturer
//	 *@param model textual description of the model
//	 *@param transform additional transformation applied to buffer contents during presentation
//
	geometry fn (voidptr, &Wl_output, int, int, int, int, int, &i8, &i8, int)
//*	 *advertise available modes for the output
//	 *	 *The mode event describes an available mode for the output.
//	 *	 *The event is sent when binding to the output object and there
//	 *will always be one mode, the current mode. The event is sent
//	 *again if an output changes mode, for the mode that is now
//	 *current. In other words, the current mode is always the last
//	 *mode that was received with the current flag set.
//	 *	 *Non-current modes are deprecated. A compositor can decide to
//	 *only advertise the current mode and never send other modes.
//	 *Clients should not rely on non-current modes.
//	 *	 *The size of a mode is given in physical hardware units of the
//	 *output device. This is not necessarily the same as the output
//	 *size in the global compositor space. For instance, the output
//	 *may be scaled, as described in wl_output.scale, or transformed,
//	 *as described in wl_output.transform. Clients willing to retrieve
//	 *the output size in the global compositor space should use
//	 *xdg_output.logical_size instead.
//	 *	 *The vertical refresh rate can be set to zero if it doesn't make
//	 *sense for this output (e.g. for virtual outputs).
//	 *	 *The mode event will be followed by a done event (starting from
//	 *version 2).
//	 *	 *Clients should not use the refresh rate to schedule frames.
//	 *Instead, they should use the C.wl_surface.frame event or the
//	 *presentation-time protocol.
//	 *	 *Note: this information is not always meaningful for all outputs.
//	 *Some compositors, such as those exposing virtual outputs, might
//	 *fake the refresh rate or the size.
//	 *@param flags bitfield of mode flags
//	 *@param width width of the mode in hardware units
//	 *@param height height of the mode in hardware units
//	 *@param refresh vertical refresh rate in mHz
//
	mode fn (voidptr, &Wl_output, u32, int, int, int)
//*	 *sent all information about output
//	 *	 *This event is sent after all other properties have been sent
//	 *after binding to the output object and after any other property
//	 *changes done after that. This allows changes to the output
//	 *properties to be seen as atomic, even if they happen via
//	 *multiple events.
//	 *@since 2
//
	done fn (voidptr, &Wl_output)
//*	 *output scaling properties
//	 *	 *This event contains scaling geometry information that is not
//	 *in the geometry event. It may be sent after binding the output
//	 *object or if the output scale changes later. The compositor will
//	 *emit a non-zero, positive value for scale. If it is not sent,
//	 *the client should assume a scale of 1.
//	 *	 *A scale larger than 1 means that the compositor will
//	 *automatically scale surface buffers by this amount when
//	 *rendering. This is used for very high resolution displays where
//	 *applications rendering at the native resolution would be too
//	 *small to be legible.
//	 *	 *Clients should use C.wl_surface.preferred_buffer_scale instead of
//	 *this event to find the preferred buffer scale to use for a
//	 *surface.
//	 *	 *The scale event will be followed by a done event.
//	 *@param factor scaling factor of output
//	 *@since 2
//
	scale fn (voidptr, &Wl_output, int)
//*	 *name of this output
//	 *	 *Many compositors will assign user-friendly names to their
//	 *outputs, show them to the user, allow the user to refer to an
//	 *output, etc. The client may wish to know this name as well to
//	 *offer the user similar behaviors.
//	 *	 *The name is a UTF-8 string with no convention defined for its
//	 *contents. Each name is unique among all wl_output globals. The
//	 *name is only guaranteed to be unique for the compositor
//	 *instance.
//	 *	 *The same output name is used for all clients for a given
//	 *wl_output global. Thus, the name can be shared across processes
//	 *to refer to a specific wl_output global.
//	 *	 *The name is not guaranteed to be persistent across sessions,
//	 *thus cannot be used to reliably identify an output in e.g.
//	 *configuration files.
//	 *	 *Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc.
//	 *However, do not assume that the name is a reflection of an
//	 *underlying DRM connector, X11 connection, etc.
//	 *	 *The name event is sent after binding the output object. This
//	 *event is only sent once per output object, and the name does not
//	 *change over the lifetime of the wl_output global.
//	 *	 *Compositors may re-use the same output name if the wl_output
//	 *global is destroyed and re-created later. Compositors should
//	 *avoid re-using the same name if possible.
//	 *	 *The name event will be followed by a done event.
//	 *@param name output name
//	 *@since 4
//
	name fn (voidptr, &Wl_output, &i8)
//*	 *human-readable description of this output
//	 *	 *Many compositors can produce human-readable descriptions of
//	 *their outputs. The client may wish to know this description as
//	 *well, e.g. for output selection purposes.
//	 *	 *The description is a UTF-8 string with no convention defined for
//	 *its contents. The description is not guaranteed to be unique
//	 *among all wl_output globals. Examples might include 'Foocorp 11"
//	 *Display' or 'Virtual X11 output via :1'.
//	 *	 *The description event is sent after binding the output object
//	 *and whenever the description changes. The description is
//	 *optional, and may not be sent at all.
//	 *	 *The description event will be followed by a done event.
//	 *@param description output description
//	 *@since 4
//
	description fn (voidptr, &Wl_output, &i8)
}
//* *@ingroup iface_wl_output
//
//* *@ingroup iface_wl_output
//
//* *@ingroup iface_wl_output
//
//* *@ingroup iface_wl_output
//
//* *@ingroup iface_wl_output
//
//* *@ingroup iface_wl_output
//
//* *@ingroup iface_wl_output
//
//* *@ingroup iface_wl_output
//
//*@ingroup iface_wl_output
//*@ingroup iface_wl_output
//*@ingroup iface_wl_output
//* *@ingroup iface_wl_output
// * *Using this request a client can tell the server that it is not going to
// *use the output object anymore.
//
//* *@ingroup iface_wl_region
//
//* *@ingroup iface_wl_region
//
//* *@ingroup iface_wl_region
//
//*@ingroup iface_wl_region
//*@ingroup iface_wl_region
//* *@ingroup iface_wl_region
// * *Destroy the region.  This will invalidate the object ID.
//
//* *@ingroup iface_wl_region
// * *Add the specified rectangle to the region.
//
//* *@ingroup iface_wl_region
// * *Subtract the specified rectangle from the region.
//
pub enum Wl_subcompositor_error {
//*	 *the to-be sub-surface is invalid
//
	wl_subcompositor_error_bad_surface = 0
//*	 *the to-be sub-surface parent is invalid
//
	wl_subcompositor_error_bad_parent = 1
}

// WL_SUBCOMPOSITOR_ERROR_ENUM
//* *@ingroup iface_wl_subcompositor
//
//* *@ingroup iface_wl_subcompositor
//
//*@ingroup iface_wl_subcompositor
//*@ingroup iface_wl_subcompositor
//* *@ingroup iface_wl_subcompositor
// * *Informs the server that the client will not be using this
// *protocol object anymore. This does not affect any other
// *objects, wl_subsurface objects included.
//
//* *@ingroup iface_wl_subcompositor
// * *Create a sub-surface interface for the given surface, and
// *associate it with the given parent surface. This turns a
// *plain C.wl_surface into a sub-surface.
// * *The to-be sub-surface must not already have another role, and it
// *must not have an existing wl_subsurface object. Otherwise the
// *bad_surface protocol error is raised.
// * *Adding sub-surfaces to a parent is a double-buffered operation on the
// *parent (see C.wl_surface.commit). The effect of adding a sub-surface
// *becomes visible on the next time the state of the parent surface is
// *applied.
// * *The parent surface must not be one of the child surface's descendants,
// *and the parent must be different from the child surface, otherwise the
// *bad_parent protocol error is raised.
// * *This request modifies the behaviour of C.wl_surface.commit request on
// *the sub-surface, see the documentation on wl_subsurface interface.
//
pub enum Wl_subsurface_error {
//*	 *C.wl_surface is not a sibling or the parent
//
	wl_subsurface_error_bad_surface = 0
}

// WL_SUBSURFACE_ERROR_ENUM
//* *@ingroup iface_wl_subsurface
//
//* *@ingroup iface_wl_subsurface
//
//* *@ingroup iface_wl_subsurface
//
//* *@ingroup iface_wl_subsurface
//
//* *@ingroup iface_wl_subsurface
//
//* *@ingroup iface_wl_subsurface
//
//*@ingroup iface_wl_subsurface
//*@ingroup iface_wl_subsurface
//* *@ingroup iface_wl_subsurface
// * *The sub-surface interface is removed from the C.wl_surface object
// *that was turned into a sub-surface with a
// *wl_subcompositor.get_subsurface request. The C.wl_surface's association
// *to the parent is deleted. The C.wl_surface is unmapped immediately.
//
//* *@ingroup iface_wl_subsurface
// * *This schedules a sub-surface position change.
// *The sub-surface will be moved so that its origin (top left
// *corner pixel) will be at the location x, y of the parent surface
// *coordinate system. The coordinates are not restricted to the parent
// *surface area. Negative values are allowed.
// * *The scheduled coordinates will take effect whenever the state of the
// *parent surface is applied.
// * *If more than one set_position request is invoked by the client before
// *the commit of the parent surface, the position of a new request always
// *replaces the scheduled position from any previous request.
// * *The initial position is 0, 0.
//
//* *@ingroup iface_wl_subsurface
// * *This sub-surface is taken from the stack, and put back just
// *above the reference surface, changing the z-order of the sub-surfaces.
// *The reference surface must be one of the sibling surfaces, or the
// *parent surface. Using any other surface, including this sub-surface,
// *will cause a protocol error.
// * *The z-order is double-buffered. Requests are handled in order and
// *applied immediately to a pending state. The final pending state is
// *copied to the active state the next time the state of the parent
// *surface is applied.
// * *A new sub-surface is initially added as the top-most in the stack
// *of its siblings and parent.
//
//* *@ingroup iface_wl_subsurface
// * *The sub-surface is placed just below the reference surface.
// *See wl_subsurface.place_above.
//
//* *@ingroup iface_wl_subsurface
// * *Change the commit behaviour of the sub-surface to synchronized
// *mode, also described as the parent dependent mode.
// * *In synchronized mode, C.wl_surface.commit on a sub-surface will
// *accumulate the committed state in a cache, but the state will
// *not be applied and hence will not change the compositor output.
// *The cached state is applied to the sub-surface immediately after
// *the parent surface's state is applied. This ensures atomic
// *updates of the parent and all its synchronized sub-surfaces.
// *Applying the cached state will invalidate the cache, so further
// *parent surface commits do not (re-)apply old state.
// * *See wl_subsurface for the recursive effect of this mode.
//
//* *@ingroup iface_wl_subsurface
// * *Change the commit behaviour of the sub-surface to desynchronized
// *mode, also described as independent or freely running mode.
// * *In desynchronized mode, C.wl_surface.commit on a sub-surface will
// *apply the pending state directly, without caching, as happens
// *normally with a C.wl_surface. Calling wl_surface.commit on the
// *parent surface has no effect on the sub-surface's C.wl_surface
// *state. This mode allows a sub-surface to be updated on its own.
// * *If cached state exists when C.wl_surface.commit is called in
// *desynchronized mode, the pending state is added to the cached
// *state, and applied as a whole. This invalidates the cache.
// * *Note: even if a sub-surface is set to desynchronized, a parent
// *sub-surface may override it to behave as synchronized. For details,
// *see wl_subsurface.
// * *If a surface's parent surface behaves as desynchronized, then
// *the cached state is applied on set_desync.
//
//* *@ingroup iface_wl_fixes
//
//* *@ingroup iface_wl_fixes
//
//*@ingroup iface_wl_fixes
//*@ingroup iface_wl_fixes
//* *@ingroup iface_wl_fixes
//
//* *@ingroup iface_wl_fixes
// * *This request destroys a wl_registry object.
// * *The client should no longer use the wl_registry after making this
// *request.
// * *The compositor will emit a wl_display.delete_id event with the object ID
// *of the registry and will no longer emit any events on the registry. The
// *client should re-use the object ID once it receives the
// *wl_display.delete_id event.
//
